* Manual
** Distribution
** Introduction
** The Organization of the Screen
   Goes through an overview of
   - Frame :: The Graphical window or entire terminal running Emacs.
   - Menu Bar :: Organization of various commands and instructions in
                 Emacs's.
   - Tool Bar :: Only appears when running Emacs in a graphical
                 display. List of shortcuts to common commands.
   - Echo Area :: Where informative messages are displayed and where
                  you enter information when Emacs asks for it.
   - Window :: Area of editing below the tool bar (if one exists) and
               above the echo area.
   - Buffer :: the text or other graphics you are editing or viewing.
   - Mode Line :: This displays various information about what is
                  going on in the buffer.
*** Point
    Basically the cursor. Comes from ~.~ which was the original
    command for accessing the editing position way back when.
*** The Echo Area
    Detailed explanation of stuff.
    - Minibuffer :: a special window where you can input arguments to
                    commands within the [[Echo Area]]
*** The Mode Line
    #+BEGIN_SRC
    cs:ch-fr  buf     pos line   (major minor)
    #+END_SRC
    Explanation:
    - ~cs~ :: Character Set. Depends on the encoding of the document
    - ~:~ :: Changes depending on the newline convention.
      - ~:~ or ~Unix~ :: Lines end in newline character
      - ~\~ or ~DOS~ :: Lines end in carriage return, linefeed
      - ~/~ or ~Mac~ :: Lines end in carriage return
      - ~@~ :: When the frame was created for ~emacsclient~
    - ~ch~ :: Status of buffer
      - ~--~ :: Buffer is unchanged from file
      - ~**~ :: Buffer is modified from file
      - ~%%~ :: Unmodified read only buffer
      - ~%*~ :: Modified read only buffer
    - ~-~ :: Location of file for current buffer
      - ~-~ :: Local file
      - ~@~ :: Remote file
    - ~fr~ :: Name of selected frame. Only relevant for text terminals
      - ~F1~ :: Name of initial frame
    - ~buf~ :: Name of buffer. Normally the file name.
    - ~pos~ :: Indicates whether there is additional text above the
      top of the window or below the bottom.
      - ~All~ :: The entire buffer is visible in the window
      - ~Top~ :: You are looking at the beginning of the buffer
      - ~Bot~ :: You are looking at the end of the buffer
      - ~nn%~ :: This means /nn/ is the percentage of the buffer above
        the top of the window.
    - ~line~ :: the character ~L~ followed by the line number at
      point.
    - ~major~ :: Name of the major mode used in the buffer.
    - ~minor~ :: A list of some of the enabled minor modes, or
      relevant features.
      - ~Narrow~ :: Buffer being displayed has editing restricted to
        only a portion of it's text.
      - ~Def~ :: A keyboard macro is currently being defined.
    - ~(...)~ :: If Emacs is inside a recursive editing level, square
      brackets ~[...]~ appear around the parentheses that surround
      the modes

    Extra Functionality: 
    - Hovering around the mode line shows tool tips.
    - Clicking on different parts of the mode line performs various
      commands

    Words and concepts defined or mentioned:
    - Major Mode :: the principal editing mode for a given buffer.
    - Minor Mode :: Optional editing modes that provide additional
      features on top of the major mode.
    - Narrowing :: When you restrict editing to only a portion of
      buffer.
    - Keyboard Macro :: Mentioned not defined
    - Recursive Edit :: Mentioned not defined
    - Tooltips :: Mentioned not defined
*** The Menu Bar
    Some interesting details about the menu bar.

    Mentions the concept:
    - Variable
** Kinds of User Input
   Some Syntax
   - <SPC> :: The space-bar
   - <RET> :: The Return or Enter key
   - <TAB> :: The Tab key
   - <DEL> :: The Delete key
   - <ESC> :: The Esc or Escape key
   - <F1> :: The F1 or first function key
   - <Home> :: The Home key
   - <LEFT> :: The Left Arrow key
   - <Control> or <Ctrl> :: The Control or Ctrl key (not different
                            keys)
   - <Meta> :: The Meta or Alt key
   - ~Control-a~ or ~C-a~ :: Holding down the <Ctrl> key while
     pressing ~a~
   - ~<Meta>-a~ or ~M-a~ :: Holding down the <Alt> key while pressing
     ~a~
   - ~C-M-a~ :: Holding down <Ctrl> and <Alt> while pressing ~a~

   These commands might be blocked by the OS
   - ~M-<TAB>~
   - ~M-<SPC>~
   - ~C-M-d~
   - ~C-M-l~
** Keys
   Definitions:
   - Key Sequence or Key :: A sequence of one or more input events
     that is meaningful as a unit.
     - Complete Key :: A Key Sequence that invokes a command
     - Prefix Key :: A Key Sequence that isn't long enough to invoke a
       command

   All Key Sequences are either Complete Keys or Prefix Keys.

   These are the default Prefix Keys
   - ~C-c~
   - ~C-h~ or ~<F1>~
   - ~C-x~
   - ~C-x <RET>~
   - ~C-x @~
   - ~C-x a~
   - ~C-x n~
   - ~C-x r~
   - ~C-x v~
   - ~C-x 4~
   - ~C-x 5~
   - ~C-x 6~ or ~<F2>~
   - ~<ESC>~
   - ~M-g~
   - ~M-o~
** Keys and Commands
   Definitions
   - Command :: a name used to store an action to perform in Emacs
   - Function :: Not defined, but mentioned
   - Keymaps :: Not defined, but mentioned
   - Variable :: a name used to store a value
** Entering Emacs
   Start Emacs from the shell.
   #+BEGIN_SRC sh
   emacs
   #+END_SRC

   Run Emacs in the background of a terminal to continue to use the
   terminal.
   #+BEGIN_SRC sh
   emacs &
   #+END_SRC

   Open ~foo.txt~ in Emacs
   #+BEGIN_SRC sh
   emacs foo.txt
   #+END_SRC

   Vocabulary mentioned or defined
   - Kill Ring :: Not defined but mentioned
   - Registers :: Not defined but mentioned
   - Undo History :: Not defined but mentioned
   - Mark Ring :: Not defined but mentioned
** Exiting Emacs
** Basic Editing Commands
*** Inserting Text
*** Changing the Location of Point
*** Erasing Text
*** Undoing Changes
*** Files
*** Help
*** Blank Lines
*** Continuation Lines
*** Cursor Position Information
*** Numeric Arguments
    Examples
    #+BEGIN_SRC
    M-5 C-n
    #+END_SRC
    Move down five (5) lines.

    #+BEGIN_SRC
    M-- C-n
    #+END_SRC
    Move up one (1) line.

    #+BEGIN_SRC
    M-- 3 C-n
    #+END_SRC
    Move up three (3) lines

    #+BEGIN_SRC
    M-5 0 C-n
    #+END_SRC
    Move down fifty (50) lines.

    #+BEGIN_SRC
    M-5 C-u 0
    #+END_SRC
    Insert five (5) copies of ~0~.

    #+BEGIN_SRC
    C-u 2 5 C-n
    #+END_SRC
    Move down twenty-five (25) lines

    #+BEGIN_SRC
    C-u - 1 2 C-n
    #+END_SRC
    Move up twelve (12) lines

    #+BEGIN_SRC
    C-u - C-n
    #+END_SRC
    Move up one (1) line

    #+BEGIN_SRC
    C-u C-n
    #+END_SRC
    Move down four (4) lines

    #+BEGIN_SRC
    C-u C-u C-n
    #+END_SRC
    Move down sixteen (16) lines

    #+BEGIN_SRC
    C-u 6 4 a
    #+END_SRC
    Insert sixty-four (64) copies of the character ~a~.

    #+BEGIN_SRC
    C-u 6 4 C-u 1
    #+END_SRC
    Insert sixty-four (64) copies of the character ~1~.
*** Repeating a Command
    Example
    #+BEGIN_SRC
    C-u 2 0 C-d
    C-x z z z
    #+END_SRC
    Delete 80 characters.
** The Minibuffer
*** Using the Minibuffer
    Can exit the minibuffer using ~C-g~
*** Minibuffers for File Names
    Options to change file/directory
    - ~M-n~ :: Next default for file name
    - ~M-<DEL>~ :: Kill directory name backwards
    - ~C-a C-k~ :: Clear entire minibuffer

    When file is a remote file:
    - a double slash ignores the file-name but keeps the method, host
      and username.
    - three slashes in a row ignores everything, both file-name and
      the method, host and username.

    #+BEGIN_SRC
    ~/
    #+END_SRC
    home directory

    #+BEGIN_SRC
    ~user-id/
    #+END_SRC
    The home directory of a user whose login name is /user-id/
*** Editing in the Minibuffer
    The following commands behave differently in the minibuffer
    compared with standard buffers:
    - ~<RET>~
    - ~<TAB>~
    - ~<SPC>~
    - ~?~

    You can use ~C-q~ to insert these into the minibuffer as you would
    expect them to be inserted.

    The minibuffer is displayed in the Echo Area. When the minibuffer
    is active, it can be thought of as it's own window. You can
    navigate windows how you normally would and return to the
    minibuffer as if it is it's own window. However standard windows
    can be split, and the Echo Area cannot be split into multiple
    windows.

    Clicking ~mouse-1~ in the Echo Area when the minibuffer is not
    active shows the ~*Messages*~ buffer in a new window.
*** Completion
    - Completion :: A helpful feature of Emacs to help enter
      arguments. This means that after you type part of the argument,
      Emacs can fill in the rest, or some of it, based on what was
      typed so far.
**** Completion Example
     #+BEGIN_SRC
     M-x c u s <TAB> i <TAB> - v <TAB> 
     #+END_SRC
     Enter ~customize-variable~ into the minibuffer as a command to
     run.
**** Completion Commands
**** Completion Exit
     There are Four types of behavior for the command
     ~minibuffer-complete-and-exit~.

     - Strict Completion
       - If minibuffer is exact match :: Exits the minibuffer.
       - If minibuffer completes to exact match :: Complete match and
         exit the minibuffer.
       - Else :: Attempts to complete, refuses to exit, displays "[No
         match]"
     - Cautious Completion
       - If minibuffer is exact match :: Exits the minibuffer.
       - If minibuffer completes to exact match :: Complete match,
         does not exit the minibuffer.
       - Else :: (unsure of exact behavior)
     - Permissive Completion
       - Any context :: Exits the minibuffer.
     - Permissive Completion with Confirmation
       - After typing <TAB> to partial completion :: does not exit
         minibuffer, displays "[Confirm]".
       - Else :: Exits the minibuffer.
**** How Completion Alternatives Are Chosen
     Completion tries each style and then moves onto the next in the
     list if unsuccessful. Here is the list in order:
     - ~basic~ :: A matching completion alternative must have the same
       beginning as the text in the minibuffer before
       point. Furthermore, if there is any text in the minibuffer
       after point, the rest of the completion alternative must
       contain that text as a sub-string.
     - ~partial-completion~ :: This aggressive completion style
       divides the minibuffer text into words separated by hyphens or
       spaces, and completes each word separately. (for example, when
       completing command names, 'em-l-m' completes to
       'emacs-lisp-mode'.) Furthermore a '*' in the minibuffer text is
       treated as a wildcard - it matches any string of characters at
       the corresponding position in the completion alternative.
     - ~emacs22~ :: This completion style is similar to ~basic~,
       except that it ignores the text in the minibuffer after
       point. It is so-named because it corresponds to the completion
       behavior in Emacs 22.

     Additional list options
     - ~substring~ :: A matching completion alternative must contain
       the text in the minibuffer before point, and the text in the
       minibuffer after point, as sub-strings (in that same
       order). Thus if the text in the minibuffer is 'foobar', with
       point between 'foo' and 'bar', that matches 'dfooebarf', where
       d, e, and f can be any string including the empty string.
     - ~initials~ :: This very aggressive completion style attempts to
       complete acronyms and initialisms. For example, when completing
       command names, it matches 'lch' to 'list-command-history'.
     - ~emacs21~ :: Only matches that start with the text in the
       minibuffer are considered, regardless of point location.
**** Completion Options     
*** Minibuffer History
*** Repeating Minibuffer Commands
    Vocabulary
    - Command History :: Special history list that records complex
      commands that required an argument from the minibuffer.
*** Entering passwords
    Entering passwords is a slightly different context than the
    minibuffer is normally.

    Most features and commands associated with the minibuffer /cannot/
    be used when entering a password. No completion, no changing
    windows.

    - ~<DEL>~ :: removes last character entered.
    - ~C-u~ :: deletes everything you have typed so far.
    - ~C-g~ :: quits the password prompt.
    - ~C-y~ :: inserts the current kill into the password.
    - ~<RET>~ OR ~<ESC>~ :: submit password.
*** Yes or No Prompts
    There are two types of yes or no prompts.

    The first kind ends an Echo Area prompt with ~(y or n)~.
    - ~C-l~ :: recenter the selected window
    - ~C-v~ OR ~<PageDown>~ OR ~<next>~ :: scroll forward.
    - ~M-v~ OR ~<PageUp>~ OR ~<prior>~ :: scroll backward.
    - ~C-M-v~ :: scrolls forward in the next window.
    - ~C-M-S-v~ :: scrolls backward in the next window.
    - ~C-g~ :: dismisses query and quits the command.

    The second kind ends an Echo Area prompt with ~(yes or no)~. This
    behaves the exact same as standard minibuffer context
** Running Commands by Name
** Help
   When looking for a feature but don't know what it's called, here is
   the suggested method of how to find it in the following order:
   - ~C-h a /topics/ <RET>~ :: This is an apropos command, literally
     runs ~apropos-command~. Searches for commands whose names match
     the argument /topics/
   - ~C-h r i /topic/ <RET>~ :: This navigates to the
     Emacs manual and then searches for /topic/ in the indices.
   - ~C-h r s /topic/ <RET>~ :: Similar as above, but
     searches the text of the manual rather than the indices
   - ~C-h C-f~ :: Displays the Emacs FAQ, using Info.
   - ~C-h p~ :: Displays the available Emacs packages based on
     keywords.

   Additionally, typing one of the following commands after a prefix
   command can mean seeing a list of possible complete keys:
   - ~C-h~
   - ~<F1>~
   - ~?~
*** Help Summary
*** Documentation for a Key
*** Help by Command or Variable Name
*** Apropos
    When searching apropos, entering one word will look for that word
    anywhere in the name. Entering more than one word will look for
    two of the provided words anywhere in the name.

    If text contains regex characters: ~^$*+?.\[~ the text to search
    is interpreted as a regular expression

    Helpful apropos words
    - char
    - line
    - word
    - sentence
    - paragraph
    - region
    - page
    - sexp
    - list
    - defun
    - rect
    - buffer
    - frame
    - window
    - face
    - file
    - dir
    - register
    - mode
    - beginning
    - end
    - forward
    - backward
    - next
    - previous
    - up
    - down
    - search
    - goto
    - kill
    - delete
    - mark
    - insert
    - yank
    - fill
    - indent
    - case
    - change
    - set
    - what
    - list
    - find
    - view
    - describe
    - default

    By default, all apropos commands except ~apropos-documentation~
    list their results in alphabetical order.

    The ~apropos-documentation~ command lists its results in order of
    relevance by default.
*** Help Mode Commands
    Vocabulary mentioned:
    - Faces
*** Keyword Search for Packages
*** Help for International Language Support
*** Other Help Commands    
*** Help Files
*** Help on Active Text and Tooltips
** The Mark and the Region
   Vocabulary
   - Mark :: An arbitrary point you define that stays in place while
     you move the point around. Deactivates after editing or
     quitting.
   - Region :: The portion of the buffer that is contained between the
     Mark and the Point. Only active when Mark is active.

   Setting the mark in one buffer has no effect on the marks in other
   buffers. When you return to a buffer with an active mark, the mark
   is at the same place as before. When multiple windows show the same
   buffer, they can have different values of point, and thus different
   regions, but they all share one common mark position.
*** Setting the Mark
    Vocabulary:
    - Shift Selection :: You can set the mark by holding down the
      shift key while typing certain cursor motion commands (such as
      ~S-<RIGHT>~, ~S-C-f~, ~S-C-n~, etc.).
    - Primary Selection :: Mentioned not well defined.

    Whenever the mark is active, you can deactivate it by typing
    ~C-g~. Most commands that operate on the region also automatically
    deactivate the mark.

    Many commands that insert text, such as ~C-y~ (~yank~), set the
    mark at the other end of the inserted text, without activating
    it. You can tell that a command does this when it shows '~Mark
    set~' in the echo area.
*** Commands to Mark Textual Objects
    Repeated invocations of ~M-@~ extend the region by advancing the
    mark one word at a time. As an exception, if the mark is active
    and located before point, ~M-@~ moves the mark backwards from its
    current position one word at a time.

    Similarly repeated invocations of ~C-M-<SPC>~ extend the region to
    subsequent expressions.

    In fact for all ~mark~-COMMAND commands the following is
    true. Repeated invocations play the same role as above, extending
    the region to consecutive objects.
*** Operating on the Region
    Example commands on region:
    - ~C-w~ :: Kill Region
    - ~M-w~ :: Copy Region to kill ring
    - ~C-x C-l~ :: Entire region to lower case
    - ~C-x C-u~ :: Entire region to upper case
    - ~C-u C-/~ :: Undo changes within region
    - ~M-%~ :: Find and replace within region
    - ~C-x <TAB>~ OR ~C-M-\~ :: Indent region
    - ~M-x fill-region~ :: Fill it as text
    - ~M-$~ :: Check spelling of words within region
    - ~M-x eval-region~ :: Evaluate region as Lisp code
    - ~C-x r s~ :: Save region in a register
    - Save region in a buffer or a file.
    - ~<DEL>~ OR ~<Delete>~ :: Delete the text in the region
*** The Mark Ring
    Each buffer remembers the previous locations of the mark, in the
    mark ring. Commands that set the mark also push the old mark onto
    this ring. One of the uses of the mark ring is to remember spots
    that you may want to go back to.

    ~C-<SPC> C-<SPC>~ is a way to set the mark, push it onto the mark
    ring, all without activating it.

    When Transient Mark mode is off, ~C-<SPC> C-<SPC>~ instead
    activates Transient Mark mode temporarily.

    To return to a marked position, use ~set-mark-command~ with a
    prefix argument: ~C-u C-<SPC>~. This moves point to where the mark
    was, and deactivates the mark if it was active. Each subsequent
    ~C-u C-<SPC>~ jumps to a prior position stored in the mark
    ring. The positions you move through in this way or not lost; they
    go to the end of the ring.
*** The Global Mark Ring
    In addition to the ordinary mark ring that belongs to each buffer,
    Emacs has a single global mark ring. Each time you set a mark,
    this is recorded in the global mark ring in addition to the
    current buffer's own mark ring, if you have switched buffers since
    the previous mark setting.
*** Shift Selection
    Definition:
    - Shift Selection :: If you hold down the shift key while typing a
      cursor motion command, this sets the mark before the moving
      point, so that the region extends from the original position of
      point to its new position.

    The mark set via shift-selection behaves a little differently from
    what we have described above. Firstly, in addition to the usual
    way of deactivating the mark (such as changing the buffer text or
    typing ~C-g~), the mark is deactivated by any /unshifted/ cursor
    motion command. Secondly, any subsequent /shifted/ cursor motion
    command avoids setting the mark anew. Therefore, a series of
    shifted cursor motion commands will continuously adjust the
    region.

    Shift-selection only works if the shifted cursor motion key is not
    already bound to a separate command. For example, if you bind
    ~S-C-f~ to another command, typing ~S-C-f~ runs that command
    instead of performing a shift-selected version of ~C-f~
    (~forward-char~).

    A mark set via mouse commands behaves the same as a mark set via
    shift-selection. For example, if you specify a region by dragging
    the mouse, you can continue to extend the region using shifted
    cursor motion commands. In either case, any unshifted cursor
    motion command deactivates the mark.
*** Disabling Transient Mark Mode
    Turning off Transient Mark mode switched Emacs to an alternative
    mode of operation:
    - Setting the mark, with commands like ~C-<SPC>~ or ~C-x C-x~,
      does not highlight the region. Therefore, you can't tell by
      looking where the mark is located; you have to remember. The
      usual solution to this problem is to set the mark and then use
      it soon, before you forget where it is. You can also check where
      the mark is by using ~C-x C-x~, which exchanges the position of
      the point and the mark.
    - Some commands, which ordinarily act on the region when the mark
      is active, no longer do so. For example, normally ~M-%~
      (~query-replace~) performs replace within the region, if the
      mark is active. When Transient Mark mode is off, it always
      operates from point to the end of the buffer. Commands that act
      this way are identified in their own documentation

    While Transient Mark mode is off, you can activate it temporarily
    using ~C-<SPC> C-<SPC>~ or ~C-u C-x C-x~.

    - ~C-<SPC> C-<SPC>~ :: Set the mark at point (like plain
      ~C-<SPC>~) and enable Transient Mark mode just once, until the
      mark is deactivated.
    - ~C-u C-x C-x~ :: Exchange point and mark, activate the mark and
      enable Transient Mark mode temporarily, until the mark is next
      deactivated.

    When you specify a region with the mouse, or with shift-selection,
    this likewise activates Transient Mark mode temporarily and
    highlights the region.
** Killing and Moving Text
   - Kill :: Erase text and copy text into the "kill ring".
   - Yank :: Bring text from the "kill ring" back into the buffer.
   - Kill Ring :: Can be visualized as a set of blocks of text
     arranged in a ring, which you can access in cyclic order.
*** Deletion and Killing
    Most commands which erase text from the buffer save it in the kill
    ring. These are known as kill commands, and their names normally
    contain the word '~kill~' (e.g., ~kill-line~). The kill ring
    stores several recent kills, not just the last oen, so killing is
    a very safe operation: you don't have to worry much about losing
    text that you previously killed. The kill ring is shared by all
    buffers, so text that is killed in one buffer can be yanked into
    another buffer.

    When you use ~C-/~ (~undo~) to undo a kill command, that brings
    the killed text back into the buffer, but does not remove it from
    the kill ring.

    On graphical displays, killing text also copies it into the system
    clipboard.

    Commands that erase text but do not save it in the kill ring are
    known as delete commands; their names usually contain the word
    '~delete~'. These include ~C-d~ (~delete-char~) and ~<DEL>~
    (~delete-backward-char~), which delete only one character at a
    time, and those commands that delete only spaces or
    newlines. Commands that can erase significant amounts of
    nontrivial data generally do a kill operation instead.

    You can also use the mouse to kill and yank.
**** Deletion
**** Killing by Lines
**** Other Kill Commands
**** Options for Killing
     The kill commands work specially in a read-only buffer: they move
     over text and copy it to the kill ring, without actually deleting
     it from the buffer.
*** Yanking
    Vocabulary:
    - Yanking :: Reinserting text previously killed.

    On graphical displays, ~C-y~ first checks if another application
    has placed any text in the system clipboard more recently than the
    last Emacs kill. If so, it inserts the clipboard's text
    instead. Thus Emacs effectively treats "cut" or "copy" clipboard
    operations performed in other applications like Emacs kills,
    except that they are not recorded in the kill ring.
**** The Kill Ring
     Vocabulary
     - Kill Ring :: A list of blocks of text that were previously
       killed.

     There is only one Kill Ring, shared by all buffers, so you can
     kill text in one buffer and yank it in another buffer.

     If you make a new kill when the limit defined in ~kill-ring-max~
     has been reached, Emacs makes room by deleting the oldest entry
     in the kill ring.
**** Yanking Earlier Kills
     If the previous command was a yank command, ~M-y~ takes the text
     that was yanked and replaces it with the text from an earlier
     kill. So to recover the text of the next-to-the-last kill, first
     use ~C-y~ to yank the last kill, and then use ~M-y~ to replace it
     with the previous kill. ~M-y~ is allowed only after a ~C-y~ or
     another ~M-y~.

     You can understand ~M-y~ in terms of a last-yank pointer which
     points at an entry in the kill ring. Each time you kill, the
     last-yank pointer moves to the newly made entry at the front of
     the ring. ~C-y~ yanks the entry with the last-yank pointer points
     to. ~M-y~ moves the last-yank pointer to a different entry, and
     the text in the buffer changes to match. Enough ~M-y~ commands
     can move the pointer to any entry in the ring, so you can get any
     entry into the buffer. Eventually the pointer reaches the end of
     the ring; the next ~M-y~ loops back around to the first entry
     again.

     ~M-y~ moves the last-yank pointer around the ring, but it does
     not change the order of the entries in the ring, which always
     runs from the most recent kill at the front to the oldest one
     still remembered.

     As long as no new killing is done, the last-hank pointer remains
     at the same place in the kill ring, so repeating ~C-y~ will yank
     another copy of the same previous kill.
**** Appending Kills
     Normally, each kill command pushes a new entry onto the kill
     ring. However, two or more kill commands in a row combine their
     text into a single entry, so that a single ~C-y~ yanks all the
     text as a unit, just as it was before it was killed.

     Commands that kill forward from point add onto the end of the
     previous killed text. Commands that kill backward from point add
     text onto the beginning. This way, any sequence of mixed forward
     and backward kill commands puts all the killed text into one
     entry without rearrangement.

     If a kill command is separated from the last kill command by
     other commands (not just numeric arguments), it starts a new
     entry on the kill ring.

     A kill command following ~M-w~ (~kill-ring-save~) does not append
     to the text that ~M-w~ copied into the kill ring.
*** "Cut and Paste" Operations on Graphical Displays
    In most graphical desktop environments, you can transfer data
    (usually text) between different applications using a system
    facility called the /clipboard/. On X, two other similar
    facilities are available: the primary selection and the secondary
    selection. When Emacs is run on a graphical disply, its kill and
    yank commands integrate with these facilities, so that you can
    easily transfer text between Emacs and other graphical
    applications.

    By default, Emacs uses UTF-8 as the coding system for
    inter-program text transfers. If you find that the pasted text is
    not what you expected, you can specify another coding system by
    typing ~C-x <RET> x~ or ~C-x <RET> X~.
**** Using the Clipboard
     The /clipboard/ is the facility that most graphical applications
     use for "cutting and pasting". When the clipboard exists, the
     kill and yank commands in Emacs make use of it.

     When you kill some text with a command such as ~C-w~
     (~kill-region~), or copy it to the kill ring with a command such
     as ~M-w~ (~kill-ring-save~), that text is also put in the
     clipboard.

     When an Emacs kill command puts text in the clipboard, the
     existing clipboard contents are normally lost.

     Yank commands, such as ~C-y~ (~yank~), also use the clipboard. If
     another application "owns" the clipboard - i.e., if you cut or
     copied text there more recently than your last kill command in
     Emacs - then Emacs yanks from the clipboard instead of the kill
     ring.

     Normally, rotating the kill ring with ~M-y~ (~yank-pop~) does not
     alter the clipboard.

     Many X desktop environments support a feature called the
     /clipboard manager/. If you exit Emacs while it is the current
     "owner" of the clipboard data, and there is a clipboard manager
     running, Emacs trahsfers the clipboard data to the clipboard
     manager so that it is not lost. In some circumstances, this may
     cause a delay when exiting Emacs.

     Since strings containing NUL bytes are usually truncated when
     passed throug the clipboard, Emacs replaces such characters with
     "\0" before transferring them to the system's clipboard.

     Prior to Emacs 24, the kill and yank commands used the primary
     selection, not the clipboard. If you prefer this bejavior, change
     ~select-enable-clipboard~ to ~nil~, ~select-enable-primary~ to
     ~t~, and ~mouse-drag-copy-region~ to ~t~. In this case, you can
     use the following commands to act explicitly on the clipboard:
     ~clipboard-kill-region~; ~clipboard-kill-ring-save~; and
     ~clipboard-yank~.
**** Cut and Paste with Other Window Applications
     Under the X Window System, there exists a /primary selection/
     containing the last stretch of text selected in an X application
     (usually by dragging the mouse). Typically, this text can be
     inserted into other X applications by ~mouse-2~ clicks. The
     primary selection is separate from the clipboard. Its contents
     are more fragile; they are overwritten each time you select text
     with the mouse, whereas the clipboard is only overwritten by
     explicit cut or copy commands.

     Under X, whenever the region is active, the text in the region is
     saved in the primary selection. This applies regardless of
     whether the region was made by dragging or clicking the mouse, or
     by keyboard commands.

     MS-Windows provides no primary selection, but Emacs emulates it
     within a single Emacs session by storing the selected text
     internally. Therefore, all the features and commands related to
     the primary selection work on Windows as they do on X, for
     cutting and pasting within the same session, but not across Emacs
     sessions or with other applications.
**** Secondary Selection
     In addition to the primary selection, the X Window System
     provides a second similar facility known as the /secondary
     selection/. Nowadays, few X applications make use of the
     secondary selection, but you can access it using the following
     Emacs commands:
     - ~mouse-set-secondary~
     - ~mouse-start-secondary~
     - ~mouse-secondary-save-then-kill~
     - ~mouse-yank-secondary~
*** Accumulating Text
*** Rectangles
    Rectangle commands operate on rectangular areas of the text: all
    the characters between a certain pair of columns, in a certain
    range of lines. Emacs has commands to kill rectangles, yank killed
    rectangles, clear them out, fill them with blanks or text, or
    delete them. Rectangle commands are useful with text in
    multicolumn formats, and for changing text into or out of such
    formats.

    To specify a rectangle for a command to work on, set the mark at
    one corner and point at the opposite corner. The rectangle thus
    specified is called the /region-rectangle/. If point and the mark
    are in the same column, the region-rectangle is empty. If they are
    in the same line, the region-rectangle is one line high.

    The region-rectangle is controlled in much the same way as the
    region is controlled. But remember that a given combination of
    point and mark values can be interpreted either as a region or as
    a rectangle, depending on the command that uses them.

    Killing a rectangle is not killing in the usual sense; the
    rectangle is not stored in the kill ring, but in a special place
    that only records the most recent rectangle killed. This is
    because yanking a rectangle is so different from yanking linear
    text that different yank commands yave to be used. Yank-popping is
    not defined for rectangles.

    When yanking a rectangle, the rectangle's first line is inserted
    at point, the rectangle's second line is inserted at the same
    horizontal position one line vertically below, and so on. The
    number of lines affected is determined by the height of the saved
    rectangle.
*** CUA Bindings    
** Registers
   Vocabulary:
   - Register :: compartments were you can save test, rectangles,
     positions ans other things for later use.
   - Bookmark :: record files and positions in them

   Valid register names:
   - characters (case sensitive) :: a, b, A, C
   - digits :: 1, 2, 3
   - non-alphanumeric :: *, #, ?
   - single input event with multiple keystrokes :: C-d, M-v

   Invalid register names:
   - C-g
   - <ESC>

   Registers can store one thing at a time including but not limited
   to the following options:
   - position
   - piece of text
   - rectangle
   - number
   - window configuration
   - file name
*** Saving Positions in Registers
*** Saving Text in Registers
    When you want to insert a copy of the same piece of text several
    times, it may be inconvenient to yank it from the kill ring, since
    each subsequent kill moves that entry further down the ring. An
    alternative is to store the text in a register and later retrieve
    it.
*** Saving Rectangles in Registers
*** Saving Window Configurations in Registers
*** Keeping Numbers in Registers
    There are commands to store a number in a register, to insert the
    number in the buffer in decimal, and to increment it. These
    commands can be useful in keyboard macros.
*** Keeping File Names in Registers
*** Keyboard Macro Registers
    If you need to execute a keyboard macro frequently, it is more
    convenient to put it in a register or save it.
*** Bookmarks
    Vocabulary:
    - Bookmark :: Record a position you can jump to using long
      names. They persist automatically across Emacs
      sessions. Normally used to record where you left off reading in
      various files.

    When you kill Emacs, Emacs saves your bookmarks, if you have
    changed any bookmark values. Bookmarks are saved to the file
    '~/.emacs.d/bookmarks' (for compatibility with older versions of
    Emacs, if you have a file named '~/.emacs.bmk', that is used
    instead). The bookmark commands load your default bookmark file
    automatically. This saving and loading is how bookmarks persist
    from one Emacs session to the next.

    Bookmark position values are saved with surrounding context, so
    that ~bookmark-jump~ can find the proper position even if the file
    is modified slightly.
** Controlling the Display
*** Scrolling
    Scrolling forward or up advances the portion of the buffer
    displayed in the window; equivalently, it moves the buffer text
    upwards relative to the window. Scrolling backward or down
    displays an earlier portion of the buffer, and moves the text
    downwards relative to the window.

    In Emacs, scrolling up or down refers to the direction that the
    text moves in the window, /not/ the direction that the window
    moves relative to the text. This terminology was adopted by Emacs
    before the modern meaning of "scrolling up" and "scrolling down"
    became widespread. Hence the strange result that ~<PageDown>~
    scrolls up in the Emacs sense.

    The portion of a buffer displayed in a window always contains
    point. If you move point past the bottom or top of the window,
    scrolling occurs automatically to bring it back onscreen.
*** Recentering
    Some combinations of variables and commands can lead to clearing
    and redisplaying the screen. Redisplaying is useful in case the
    screen becomes garbled for any reason. Read the documentation for
    ~recenter-top-bottom~ and ~recenter-redisplay~ for more
    information.
*** Automatic Scrolling
    Emacs performs automatic scrolling when point moves out of the
    visible portion of the text. Normally, automatic scrolling centers
    point vertically in the window, but there are several ways to
    alter this behavior. Check out the documentation for the following
    variables:
    - ~scroll-conservitavely~
    - ~scroll-step~
    - ~scroll-up-aggressively~ / ~scroll-down-aggressively~

    Note that these variables control automatic scrolling in
    contradictory ways. Therefore, you should pick no more than one of
    these methods to customize automatic scrolling. In case you
    customize multiple variables, the order of priority is in the same
    order listed above.
*** Horizontal Scrolling
    Horizontal scrolling means shifting all the lines sideways withing
    a window, so that some of the text near the left margin is not
    displayed.

    When the text in a window is scrolled horizontally, text lines are
    truncated rather than continued. If a window shows truncated
    lines, Emacs performs automatic horizontal scrolling whenever the
    point moves off the left or right edge of the screen.

    If you use the commands ~scroll-left~ and ~scroll-right~ to scroll
    a window horizontally, that sets a lower bound for automatic
    horizontal scrolling. Automatic scrolling will continue to scroll
    the window, but never farther to the right than the amount you
    previously set by ~scroll-left~. When ~auto-hscroll-mode~ is set
    to ~current-line~, all the lines other than the one showing the
    cursor will be scrolled by that minimal amount.
* Vocabulary
** Basics
*** Frame
    [[The Organization of the Screen][First Defined]]
*** Menu Bar
    [[The Organization of the Screen][First Defined]]
*** Tool Bar
    [[The Organization of the Screen][First Defined]]
*** Echo Area
    [[The Organization of the Screen][First Defined]]
    [[The Echo Area][Details]]
*** Window
    [[The Organization of the Screen][First Defined]]
*** Buffer
    [[The Organization of the Screen][First Defined]]
*** Mode Line
    [[The Organization of the Screen][First Defined]]
    [[The Mode Line][Details]]
*** Point
    [[Point][first Defined]]
*** Major Mode
    [[The Mode Line][First Defined]]
*** Minor Mode
    [[The Mode Line][First Defined]]
*** Variable
    [[The Menu Bar][first mentioned]]
    [[Keys and Commands][First Defined]]
** Keys
*** Key Sequence
    [[Keys][First Defined]]
*** Complete Key
    [[Keys][First Defined]]
*** Prefix Key
    [[Keys][First Defined]]
** Minibuffer
*** Minibuffer
    [[The Echo Area][First Defined]]
*** Completion
    [[Completion][First Defined]]
*** Command History
    [[Repeating Minibuffer Commands][First Defined]]
** The Mark and the Region
*** Mark
    [[The Mark and the Region][First Defined]]
*** Region
    [[The Mark and the Region][First Defined]]
*** Shift Selection
    [[Setting the Mark][First Defined]]
    [[Shift Selection][Fully Defined]]
*** Mark Ring
    [[Entering Emacs][first mentioned]]
    [[The Mark Ring][First Defined]]
** Killing and Moving Text
*** Kill
    [[Killing and Moving Text][First Defined]]
*** Yank
    [[Killing and Moving Text][First Defined]]
    [[Yanking][Fully Defined]]
*** Kill Ring
    [[Entering Emacs][first mentioned]]
    [[Killing and Moving Text][First Defined]]
*** Clipboard
    [["Cut and Paste" Operations on Graphical Displays][first mentioned]]
    [[Using the Clipboard][First Defined]]
*** Primary Selection
    [["Cut and Paste" Operations on Graphical Displays][first mentioned]]
    [[Cut and Paste with Other Window Applications][First Defined]]
** Registers
*** Register
    [[Registers][First Defined]]
*** Bookmark
    [[Registers][first mentioned]]
    [[Bookmarks][First Defined]]
** Controlling the Display
*** Horizontal Scrolling
    [[Horizontal Scrolling][First Defined]]
** Uncategorized
*** Narrowing
    [[The Mode Line][First Defined]]
*** Keyboard Macro
    [[The Mode Line][first mentioned]]
*** Recursive Edit
    [[The Mode Line][first mentioned]]
*** Tooltips
    [[The Mode Line][first mentioned]]
*** Function
    [[Keys and Commands][first mentioned]]
*** Keymaps
    [[Keys and Commands][first mentioned]]
*** Registers
    [[Entering Emacs][first mentioned]]
*** Undo History
    [[Entering Emacs][first mentioned]]
*** Faces
    [[Help Mode Commands][first mentioned]]
*** Primary Selection
    [[Setting the Mark][first mentioned]]
* Mode
** The Organization of the Screen
*** Size Indication mode
    you can display the size of the buffer in the Mode Line

    [[The Mode Line][first mention]]
*** Column Number mode
    You can display the current column in the Mode Line

    [[The Mode Line][first mention]]
** Basic Editing Commands
*** Auto Fill mode
    Splits lines automatically when they get too long

    [[Inserting Text][first mention]]
*** Overwrite mode
    Causes inserted characters to replace (overwrite) existing text,
    instead of shoving it to the right.

    [[Inserting Text][first mentioned]]
*** Visual Line mode
    Enables word wrapping: instead of wrapping long lines exactly at
    the right window edge, Emacs wraps them at the word boundaries
    (i.e., space or tab characters) nearest to the right window
    edge. Visual Line mode also redefines editing commands such as
    C-a, C-n, and C-k to operate on screen lines rather than logical
    lines.
*** Line Number mode
    The current line number of point appears in the mode line when
    this mode is enabled.
*** Column Number mode
    Display the current column number in the mode line.
*** HL Line mode
    Highlights the line containing point.
** The Minibuffer
*** Minibuffer Electric Default mode
    Emacs hides the default argument as soon as you modify the
    contents of the minibuffer.
*** File Name Shadow mode
    The ignored part of the file name is dimmed if the terminal allows
    it. And to disable this dimming disable this mode.
*** Minibuffer Inactive mode
    When the minibuffer is not active in the Echo Area, then that is a
    particular mode that has hooks etc.
** Help
*** Help Mode
    Help buffers provide the same commands as View mode (not yet
    defined). Help buffers normally provide a definition, a list of
    commands or symbols. Not as heavily formatted as documentation,
    but still provides very helpful insight.
** The Mark and the Region
*** Transient Mark mode
    When a region is active, Emacs indicates its extent by
    highlighting the text within it. After certain non-motion
    commands, including any command that changes the text in the
    buffer, Emacs automatically deactivates the mark; this turns off
    the highlighting.
*** Delete Selection mode
    By default, text insertion occurs normally even if the mark is
    active - for example, typing ~a~ inserts the character 'a', then
    deactivates the mark. Delete Selection mode, a minor mode,
    modifies this behavior: if you enable this mode, then inserting
    text while the mark is active causes the text in the region to be
    deleted first.
*** Shift Select mode
    Minor mode specifying that shift selection is allowed. Set
    corresponding variable to ~nil~ to turn off shift-selection
** Killing and Moving Text
*** Rectangle Mark mode
    When this mode is enabled, commands that resize the region do so
    in a rectangular fashion, and killing and yanking operate on the
    rectangle. The mode persists only as long as the region is
    active.
*** CUA mode
    Sets up key bindings that are compatible with the Common User
    Access (CUA) system used in many other applications.

    When CUA mode is enabled, they keys ~C-x~, ~C-c~, ~C-v~, and ~C-z~
    invoke commands that cut (kill), copy, paste (yank), and undo
    respectively. The ~C-x~ and ~C-c~ keys perform cut and copy only
    if the region is active. Otherwise, they still act as prefix keys,
    so that standard Emacs commands like ~C-x C-c~ still work.

    To enter an Emacs command like ~C-x C-f~ while the mark is active,
    use one of the following methods: either hold ~<Shift>~ together
    with the prefix key, e.g., ~S-C-x C-f~, or quickly type the prefix
    key twice, e.g., ~C-x C-x C-f~.

    this mode by default activates Delete-Selection mode so that typed
    text replaces the active region.

    This mode provides enhanced rectangle support with visible
    rectangle highlighting. Use ~C-<RET>~ to start a rectangle, extend
    it using the movment commands, and cut or copy it using ~C-x~ or
    ~C-c~. ~<RET>~ moves the cursor to the next (clockwise) corner of
    the rectangle, so you can easily expand it in any
    direction. Normal text you type is inserted to the left or right
    of each line in the rectangle (on the same side as the cursor).

    With CUA you can easily copy text and rectangles into and out of
    registers by providing a one-digit numeric prefix to the kill,
    copy, and yank commands, e.g., ~C-1 C-c~ copies the region into
    register 1, and ~C-2 C-v~ yanks the contents of register 2.

    This mode also has a global mark feature which allows easy moving
    and copying of text between buffers. Use ~C-S-<SPC>~ to toggle the
    global mark on and off. When the global mark is on, all text that
    you kill or copy is automatically inserted at the global mark, and
    text you type is inserted at the global mark rather than at the
    current position.
*** CUA Rectangle Mark mode
    Uses the same rectantle support as the CUA mode without needing to
    enable CUA mode.

    Use ~C-<RET>~ to start a rectangle, extend it using the movement
    commands. <RET> moves the cursor to the next (clockwise) corner of
    the rectangle, so you can easily expand it in any
    direction. Normal text you type is inserted to the left or right
    of each line in the rectangle (on the same side as the cursor).
* Command
** The Organization of the Screen
*** what-cursor-position                                   :inform:char:echo:
    :PROPERTIES:
    :Command:  C-x =
    :Description: Display char code, position, column of character after point
    :Context:  navigating
    :END:
*** keyboard-quit                                              :undo:command:
    :PROPERTIES:
    :Command:  C-g
    :Description: Quit: Cancel running or partially typed command
    :Context:  anywhere
    :END:
*** menu-bar-open                                                      :menu:
    :PROPERTIES:
    :Command:  <F10>
    :Description: Invoke first menu bar item.
    :Context:  anywhere
    :END:
*** tmm-menubar                                                        :menu:
    :PROPERTIES:
    :Command:  M-`
    :Description: Select a menu item with the keyboard
    :Context:  anywhere
    :END:
** Keys
*** Prefix Help Man                                :inform:helps:keys:window:
    :PROPERTIES:
    :Command:  <Prefix> C-h OR <Prefix> <F1>
    :Description: Displays a list of the commands starting with that prefix
    :Context:  anywhere
    :END:
    There is one exception. The key ~<ESC> C-h~ is equivalent to
    ~C-M-h~ which is a different command. To list the commands that
    start with <ESC> one should instead use the key ~<ESC> <F1>~.
** Entering Emacs
*** help-with-tutorial                                         :helps:buffer:
    :PROPERTIES:
    :Command:  C-h t
    :Description: Open the Emacs tutorial
    :Context:  anywhere
    :END:
** Exiting Emacs
*** save-buffers-kill-terminal                                   :kill:frame:
    :PROPERTIES:
    :Command:  C-x C-c
    :Description: Kill Emacs
    :Context:  anywhere
    :END:
*** suspend-frame                                                     :frame:
    :PROPERTIES:
    :Command:  C-z
    :Description: Minimize GUI, suspend terminal Emacs
    :Context:  anywhere
    :END:
*** kill-emacs                                                   :kill:frame:
    :PROPERTIES:
    :Description: Kill Emacs without being prompted about saving
    :Context:  anywhere
    :END:
** Basic Editing Commands
*** newline                                                       :edit:char:
    :PROPERTIES:
    :Command:  <RET>
    :Description: End a line and start a new one
    :Context:  editing
    :END:
    The binding of this and ~newline-and-indent~ may be swapped
*** newline-and-indent                                            :edit:char:
    :PROPERTIES:
    :Command:  C-j
    :Description: insert newline then indent according to mode
    :Context:  editing
    :END:
    The binding of this and ~newline~ may be swapped
*** quoted-insert                                                 :edit:char:
    :PROPERTIES:
    :Command:  C-q
    :Description: Insert a non-graphic character
    :Context:  editing
    :Argument: numeric
    :END:
    There are two ways to use ~quoted-insert~.
    - ~C-q~ followed by any non-graphic character inserts that
      character
    - ~C-q~ followed by a sequence of octal digits inserts the
      character with the specified octal character code.
    A numeric argument specifies how many copies of the character to
    insert.
*** Insert Char Help Man                      :inform:helps:edit:char:window:
    :PROPERTIES:
    :Command:  C-x 8 C-h
    :Description: Show list of possible characters to insert
    :Context:  navigating
    :END:
    There are a lot of helpful characters one can insert. Check this
    out.
*** insert-char                                                   :edit:char:
    :PROPERTIES:
    :Command:  C-x 8 <RET>
    :Description: Prompts for Unicode name or code-point and inserts
    :Context:  editing
    :Argument: numeric
    :END:
    A numeric argument specifies how many copies of the character to
    insert.
*** forward-char                                                   :nav:char:
    :PROPERTIES:
    :Command:  C-f
    :Description: Move forward one character
    :Context:  navigating
    :END:
*** right-char                                                     :nav:char:
    :PROPERTIES:
    :Command:  <RIGHT>
    :Description: Move right one character
    :Context:  navigating
    :END:
*** backward-char                                                  :nav:char:
    :PROPERTIES:
    :Command:  C-b
    :Description: Move backward one character
    :Context:  navigating
    :END:
*** left-char                                                      :nav:char:
    :PROPERTIES:
    :Command:  <LEFT>
    :Description: Move left one character
    :Context:  navigating
    :END:
*** next-line                                                      :nav:line:
    :PROPERTIES:
    :Command:  C-n OR <DOWN>
    :Description: Move down one screen line
    :Context:  navigating
    :END:
*** previous-line                                                  :nav:line:
    :PROPERTIES:
    :Command:  C-p OR <UP>
    :Description: Move up one screen line
    :Context:  navigating
    :END:
*** move-beginning-of-line                                         :nav:line:
    :PROPERTIES:
    :Command:  C-a OR <Home>
    :Description: Move to the beginning of the line
    :Context:  navigating
    :END:
*** move-end-of-line                                               :nav:line:
    :PROPERTIES:
    :Command:  C-e OR <End>
    :Description: Move to the end of the line
    :Context:  navigating
    :END:
*** forward-word                                                   :nav:word:
    :PROPERTIES:
    :Command:  M-f
    :Description: Move forward one word
    :Context:  navigating
    :END:
*** right-word                                                     :nav:word:
    :PROPERTIES:
    :Command:  C-<RIGHT> OR M-<RIGHT>
    :Description: Move right one word
    :Context:  navigating
    :END:
*** backward-word                                                  :nav:word:
    :PROPERTIES:
    :Command:  M-b
    :Description: Move backward one word
    :Context:  navigating
    :END:
*** left-word                                                      :nav:word:
    :PROPERTIES:
    :Command:  C-<LEFT> OR M-<LEFT>
    :Description: Move left one word
    :Context:  navigating
    :END:
*** move-to-window-line-top-bottom                               :nav:window:
    :PROPERTIES:
    :Command:  M-r
    :Description: Move point to left margin center, top, bottom
    :Context:  navigating
    :Argument: numeric
    :END:
    A numeric argument says which screen line to place point on,
    counting downward from the top of the window (zero means the top
    line). A negative argument counts lines up from the bottom (-1
    means the bottom line).
*** beginning-of-buffer                                          :nav:buffer:
    :PROPERTIES:
    :Command:  M-< OR C-<HOME>
    :Description: Move to the top of the buffer
    :Context:  navigating
    :Argument: numeric
    :END:
    With numeric argument n, move to n/10 of the way from the top.
*** end-of-buffer                                                :nav:buffer:
    :PROPERTIES:
    :Command:  M-> OR C-<END>
    :Description: Move to the end of the buffer
    :Context:  navigating
    :END:
*** scroll-up-command                                            :nav:buffer:
    :PROPERTIES:
    :Command:  C-v OR <PageDown> OR <next>
    :Description: Scroll the display one screen forward
    :Context:  navigating
    :Argument: numeric
    :END:
    With a numeric argument, /n/, you scroll by /n/ lines; Emacs
    attempts to leave point unchanged, so that the text and point move
    up or down together. With a negative argument this behaves like
    ~scroll-down-command~.
*** scroll-down-command                                          :nav:buffer:
    :PROPERTIES:
    :Command:  M-v OR <PageUp> OR <prior>
    :Description: Scroll one screen backward
    :Context:  navigating
    :Argument: numeric
    :END:
    With a numeric argument, /n/, you scroll by /n/ lines; Emacs
    attempts to leave point unchanged, so that the text and point move
    up or down together. With a negative argument this behaves like
    ~scroll-down-command~.
*** goto-char                                                    :nav:buffer:
    :PROPERTIES:
    :Command:  M-g c
    :Description: Go to 1 indexed character in buffer
    :Context:  navigating
    :END:
*** goto-line                                                    :nav:buffer:
    :PROPERTIES:
    :Command:  M-g M-g OR M-g g
    :Description: Goto 1 indexed line number
    :Context:  navigating
    :Argument: numeric, plain
    :END:
    You can specify line number by giving command a numeric prefix
    argument. Plain prefix not yet defined.
*** move-to-column                                                 :nav:line:
    :PROPERTIES:
    :Command:  M-g <TAB>
    :Description: Move to 0 indexed column
    :Context:  navigating
    :Argument: numeric
    :END:
    If called with a prefix argument, move to the column number
    specified by the argument's numeric value.
*** set-goal-column                                              :nav:window:
    :PROPERTIES:
    :Command:  C-x C-n
    :Description: Use current column as semi-permanent goal column
    :Context:  navigating
    :Argument: plain
    :END:
    With a plain prefix argument cancels the goal column
*** delete-backward-char                            :delete:char:edit:region:
    :PROPERTIES:
    :Command:  <DEL> OR <BACKSPACE>
    :Description: Delete character before point, or region if active
    :Context:  editing
    :Argument: numeric
    :END:
    If you supply a numeric argument /n/, this commands delete /n/
    characters.
*** delete-forward-char                             :delete:char:edit:region:
    :PROPERTIES:
    :Command:  <Delete>
    :Description: Delete character after point, or region if active
    :Context:  editing
    :Argument: numeric
    :END:
    If you supply a numberic argument /n/, this commands delete /n/
    characters.
*** delete-char                                            :delete:char:edit:
    :PROPERTIES:
    :Command:  C-d
    :Description: Delete the character after point
    :Context:  editing
    :END:
*** kill-line                                         :kill:line:edit:delete:
    :PROPERTIES:
    :Command:  C-k
    :Description: Kill to the end of the line
    :Context:  editing
    :Argument: numeric
    :END:
    If used at the end of a line, it kills the line-ending newline
    character, merging the next line into the current one (thus, a
    blank line is entirely removed). Otherwise, this command kills all
    the text from the point up to the end of the line; if point was
    originally at the beginning of the line, this leaves the line
    blank.

    Spaces and tabs at the end of the line are ignored when deciding
    which case applies. As long as point is after the last
    non-whitespace character in the line, you can be sure that ~C-k~
    will kill the newline. To kill an entire non-blank line, go to the
    beginning and type ~C-k~ twice.

    When ~C-k~ is given a positive argument /n/, it kills /n/ lines
    and the newlines that follow them (text on the current line before
    point is not killed). With a negative /-n/, it kills /n/ lines
    preceding the current line, together with the text on the current
    line before point. C-k with an argument of zero kills the text
    vefore the point on the current line.
*** kill-word                                         :kill:word:edit:delete:
    :PROPERTIES:
    :Command:  M-d
    :Description: Kill forward to the end of the next word
    :Context:  editing
    :END:
*** backward-kill-word                                :kill:word:edit:delete:
    :PROPERTIES:
    :Command:  M-<DEL> OR M-<BACKSPACE>
    :Description: Kill back to the beginning of the previous word
    :Context:  editing
    :END:
*** undo                                                   :undo:edit:buffer:
    :PROPERTIES:
    :Command:  C-/ OR C-x u OR C-_
    :Description: Undo one entry of the undo records
    :Context:  editing
    :Argument: plain
    :END:
    When not in Transient Mark mode, using a plain argument limits
    undo to changes within the current region.
*** find-file                                                  :files:buffer:
    :PROPERTIES:
    :Command:  C-x C-f
    :Description: Copy file into buffer
    :Context:  anywhere
    :END:
*** save-buffer                                                :files:buffer:
    :PROPERTIES:
    :Command:  C-x C-s
    :Description: Save current buffer into associated file
    :Context:  editing
    :END:
*** describe-key                                        :helps:window:inform:
    :PROPERTIES:
    :Command:  C-h k
    :Description: find out what a key does
    :Context:  anywhere
    :END:
*** open-line                                                     :edit:line:
    :PROPERTIES:
    :Command:  C-o
    :Description: Insert a blank line after the cursor
    :Context:  editing
    :Argument: numeric
    :END:
    With a numeric argument you can make several blank lines.
*** delete-blank-lines                                   :edit:buffer:delete:
    :PROPERTIES:
    :Command:  C-x C-o
    :Description: Delete all but one of many consecutive blank lines
    :Context:  editing
    :END:
*** what-line                                                   :inform:echo:
    :PROPERTIES:
    :Description: Display the line number of point
    :Context:  navigating
    :END:
*** line-number-mode                                     :inform:buffer:mode:
    :PROPERTIES:
    :Description: Toggle automatic display of current line number
    :Context:  navigating
    :END:
*** column-number-mode                                     :inform:line:mode:
    :PROPERTIES:
    :Description: Toggle automatic display of current column number
    :Context:  navigating
    :END:
*** count-words-region                                   :inform:region:echo:
    :PROPERTIES:
    :Command:  M-=
    :Description: Display the number of lines, words, chars in region
    :Context:  navigating
    :END:
*** count-words                                          :inform:echo:region:
    :PROPERTIES:
    :Command:  C-u M-=
    :Description: Display number of lines, words, and chars in buffer or region
    :Context:  navigating
    :END:
*** what-cursor-position                              :inform:char:echo:line:
    :PROPERTIES:
    :Command:  C-x =
    :Description: Display code char, position, and column of point
    :Context:  navigating
    :END:
*** hl-line-mode                                          :mode:display:line:
    :PROPERTIES:
    :Description: Toggle highlighting of the current line
    :Context:  navigating
    :END:
*** size-indication-mode                                 :mode:inform:buffer:
    :PROPERTIES:
    :Description: Toggle automatic display of size of buffer
    :Context:  navigating
    :END:
*** display-line-numbers-mode                    :display:window:mode:inform:
    :PROPERTIES:
    :Description: Toggle displaying line numbers for every line in buffer
    :Context:  navigating
    :END:
*** digit-argument                                                     :keys:
    :PROPERTIES:
    :Command:  M-[0-9]
    :Description: Compile numeric argument for next command
    :Context:  anywhere
    :END:
*** negative-argument                                                  :keys:
    :PROPERTIES:
    :Command:  M--
    :Description: Compile negative numeric argument for next command
    :Context:  anywhere
    :END:
*** universal-argument                                                 :keys:
    :PROPERTIES:
    :Command:  C-u
    :Description: start numeric, plain, double argument
    :Context:  anywhere
    :END:
*** repeat                                                             :keys:
    :PROPERTIES:
    :Command:  C-x z
    :Description: repeat the previous Emacs command.
    :Context:  anywhere
    :END:
** The Minibuffer
*** minibuffer-electric-default-mode                    :buffer:display:echo:
    :PROPERTIES:
    :Description: Toggle Minibuffer Electric Default mode
    :Context:  anywhere
    :END:
*** file-name-shadow-mode                               :buffer:display:echo:
    :PROPERTIES:
    :Description: Toggle File Name Shadow mode
    :Context:  anywhere
    :END:
*** minibuffer-complete                                 :buffer:command:echo:
    :PROPERTIES:
    :Command:  <TAB>
    :Description: Complete the text in the minibuffer as much as possible
    :Context:  minibuffer
    :END:
    If unable to complete, display a list of possible completions
*** minibuffer-complete-word                            :buffer:command:echo:
    :PROPERTIES:
    :Command:  <SPC>
    :Description: Complete up to one word from the minibuffer text before point
    :Context:  minibuffer
    :END:
    This command is not available for arguments that often include
    spaces, such as file names.
*** minibuffer-complete-and-exit                        :buffer:command:echo:
    :PROPERTIES:
    :Command:  <RET>
    :Description: Submit minibuffer argument
    :Context:  minibuffer
    :END:
*** minibuffer-completion-help            :buffer:command:inform:window:echo:
    :PROPERTIES:
    :Command:  ?
    :Description: Display a list of completions
    :Context:  minibuffer
    :END:
*** switch-to-completions                    :buffer:command:window:nav:echo:
    :PROPERTIES:
    :Command:  M-v OR <PageUp> OR <prior>
    :Description: Selects the window showing the completion list
    :Context:  minibuffer
    :END:
*** choose-completion                            :window:command:buffer:echo:
    :PROPERTIES:
    :Command:  <RET> OR mouse-1 OR mouse-2
    :Description: Chooses the completion at point
    :Context:  completion-buffer
    :END:
*** next-completion                                      :buffer:command:nav:
    :PROPERTIES:
    :Command:  <RIGHT>
    :Description: This moves point to the following completion alternative
    :Context:  completion-buffer
    :END:
*** previous-completion                                  :buffer:command:nav:
    :PROPERTIES:
    :Command:  <LEFT>
    :Description: This moves point to the previous completion alternative
    :Context:  completion-buffer
    :END:
*** previous-history-element                          :buffer:line:hist:echo:
    :PROPERTIES:
    :Command:  M-p
    :Description: Move to the previous item in the minibuffer history
    :Context:  minibuffer
    :END:
*** next-history-element                              :buffer:line:hist:echo:
    :PROPERTIES:
    :Command:  M-n
    :Description: Move to the next item in the minibuffer history
    :Context:  minibuffer
    :END:
    If you use this command in the minibuffer when there are no later
    entries in the minibuffer history (e.g., if you haven't previously
    typed M-p), Emacs tries fetching from a list of default arguments:
    values that you are likely to enter. You can think of this as
    moving through the "future history".
*** previous-line-or-history-element              :buffer:line:nav:hist:echo:
    :PROPERTIES:
    :Command:  <UP>
    :Description: Move previous line if exists, else previous minibuffer item
    :Context:  minibuffer
    :END:
*** next-line-or-history-element                  :buffer:line:nav:hist:echo:
    :PROPERTIES:
    :Command:  <DOWN>
    :Description: Move next line if exists, else move next minibuffer item
    :Context:  minibuffer
    :END:
*** previous-matching-history-element                 :buffer:line:hist:echo:
    :PROPERTIES:
    :Command:  M-r
    :Description: Move earlier minibuffer item that matches regexp
    :Context:  minibuffer
    :Argument: numeric
    :END:
    A numeric prefix argument /n/ means to fetch the /n/-th matching
    entry.
*** next-matching-history-element                     :buffer:line:hist:echo:
    :PROPERTIES:
    :Command:  M-s
    :Description: Move later minibuffer item that matches regexp
    :Context:  minibuffer
    :Argument: numeric
    :END:
    A numeric prefix argument /n/ means to fetch the /n/-th matching
    entry.
*** repeat-complex-command                                     :command:hist:
    :PROPERTIES:
    :Command:  C-x <ESC> <ESC>
    :Description: Re-execute a recent minibuffer command from Command History
    :Context:  anywhere
    :Argument: numeric
    :END:
    With no argument, it repeats the last such command. A numeric
    argument specifies which command to repeat; 1 means the last one,
    2 the previous, and so on.
*** list-command-history                         :window:command:inform:hist:
    :PROPERTIES:
    :Description: Display command history
    :Context:  anywhere
    :END:
*** Password Delete Backwards Char                  :buffer:char:delete:echo:
    :PROPERTIES:
    :Command:  <DEL>
    :Description: Removes last character entered
    :Context:  password
    :END:
*** Password Delete All                             :buffer:delete:line:echo:
    :PROPERTIES:
    :Command:  C-u
    :Description: Deletes everything you have typed so far
    :Context:  password
    :END:
*** Password Quit                                          :undo:buffer:echo:
    :PROPERTIES:
    :Command:  C-g
    :Description: Quits the password prompt
    :Context:  password
    :END:
*** Password Yank                                          :buffer:edit:echo:
    :PROPERTIES:
    :Command:  C-y
    :Description: Inserts the current kill into the password
    :Context:  password
    :END:
*** Password Submit                                :buffer:command:line:echo:
    :PROPERTIES:
    :Command:  <RET> OR <ESC>
    :Description: Submits password
    :Context:  password
    :END:
*** Yes No Recenter Selected Window                      :window:display:nav:
    :PROPERTIES:
    :Command:  C-l
    :Description: Recenter the selected window
    :Context:  yes-no
    :END:
*** Yes No Scroll Up                                             :nav:buffer:
    :PROPERTIES:
    :Command:  C-v OR <PageDown> OR <next>
    :Description: Scroll forward
    :Context:  yes-no
    :END:
*** Yes No Scroll Down                                           :nav:buffer:
    :PROPERTIES:
    :Command:  M-v OR <PageUp> OR <previous>
    :Description: Scroll backward
    :Context:  yes-no
    :END:
*** Yes No Scroll Up Next Window                          :nav:buffer:window:
    :PROPERTIES:
    :Command:  C-M-v
    :Description: Scrolls forward in the next window
    :Context:  yes-no
    :END:
*** Yes No Scroll Down Next Window                        :nav:buffer:window:
    :PROPERTIES:
    :Command:  C-M-S-v
    :Description: Scrolls backward in the next window
    :Context:  yes-no
    :END:
*** Yes No Quit                                                :undo:command:
    :PROPERTIES:
    :Command:  C-g
    :Description: Dismisses query and quits the command
    :Context:  yes-no
    :END:
** Running Commands by Name
*** execute-extended-command                            :command:buffer:echo:
    :PROPERTIES:
    :Command:  M-x
    :Description: Run a command by name
    :Context:  anywhere
    :Argument: numeric
    :END:
    A numeric argument passes the same numeric argument along to the
    command you are trying to execute.
** Help
*** help-for-help                                       :helps:inform:window:
    :PROPERTIES:
    :Command:  C-h C-h
    :Description: View a list of help commands
    :Context:  anywhere
    :END:
*** scroll-up-command                                      :helps:nav:window:
    :PROPERTIES:
    :Command:  <SPC>
    :Description: Scroll contents of help window up
    :Context:  help
    :END:
*** scroll-down-command                                    :helps:nav:window:
    :PROPERTIES:
    :Command:  <DEL>
    :Description: Scroll contents of help window down.
    :Context:  help
    :END:
*** help-follow                                            :helps:nav:buffer:
    :PROPERTIES:
    :Command:  <RET>
    :Description: Follow cross-reference at point
    :Context:  help
    :END:
*** push-button                                               :helps:command:
    :PROPERTIES:
    :Command:  <RET>
    :Description: Perform action specified by a button at relevant location
    :Context:  help
    :END:
*** apropos-command                             :command:helps:window:search:
    :PROPERTIES:
    :Command:  C-h a
    :Description: Searches for commands whose names match provided input
    :Context:  navigating
    :END:
*** info                                                      :buffer:inform:
    :PROPERTIES:
    :Command:  C-h i
    :Description: Enter Info, the documentation browser
    :Context:  navigating
    :END:
*** Info-directory                                        :buffer:inform:nav:
    :PROPERTIES:
    :Command:  d
    :Description: Go to the Info directory node.
    :Context:  info
    :END:
*** Info-menu                                      :buffer:inform:search:nav:
    :PROPERTIES:
    :Command:  m
    :Description: Go to the node pointed to by the menu item indicated
    :Context:  info
    :END:
*** Info-index                                     :buffer:inform:search:nav:
    :PROPERTIES:
    :Command:  i
    :Description: Look up given string in this manual's index and go there
    :Context:  info
    :END:
*** Info-search                                    :buffer:inform:search:nav:
    :PROPERTIES:
    :Command:  s
    :Description: Search for given REGEXP, starting from point, go to node
    :Context:  info
    :END:
*** view-emacs-FAQ                                            :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-f
    :Description: Display the Emacs Frequently Asked Questions (FAQ) file
    :Context:  navigating
    :END:
*** finder-by-keyword                                         :window:inform:
    :PROPERTIES:
    :Command:  C-h p
    :Description: Find packages matching a given keyword
    :Context:  navigating
    :END:
*** describe-bindings                                     :window:helps:keys:
    :PROPERTIES:
    :Command:  C-h b
    :Description: Display all active key bindings: minor, major, global
    :Context:  anywhere
    :END:
*** describe-key-briefly                                   :echo:keys:inform:
    :PROPERTIES:
    :Command:  C-h c
    :Description: Show name of command associated with key sequence
    :Context:  anywhere
    :END:
*** apropos-documentation                       :helps:command:window:search:
    :PROPERTIES:
    :Command:  C-h d
    :Description: Display commands and variables with matching documentation
    :Context:  navigating
    :END:
*** view-echo-area-messages                                :echo:buffer:hist:
    :PROPERTIES:
    :Command:  C-h e
    :Description: Display the *Messages* buffer
    :Context:  anywhere
    :END:
*** describe-function                                          :window:helps:
    :PROPERTIES:
    :Command:  C-h f
    :Description: Display documentation on function with provided name
    :Context:  anywhere
    :END:
*** view-hello-file                                      :buffer:inform:char:
    :PROPERTIES:
    :Command:  C-h h
    :Description: Display the ~HELLO~ file.
    :Context:  anywhere
    :END:
*** info                                                      :buffer:inform:
    :PROPERTIES:
    :Command:  C-h i
    :Description: Run Info, the GNU documentation browser.
    :Context:  anywhere
    :Argument: numeric, plain
    :END:
    With a numeric argument /n/, ~C-h i~ selects the Info buffer
    '~*info*<n>'. This is useful if you want to browse multiple Info
    manuals simultaneously. With just a plain argument, ~C-h i~
    prompts for the name of a documentation file, so you can browse a
    file which doesn't have an entry in the top-level Info
    menu.
*** describe-key                                  :window:command:keys:helps:
    :PROPERTIES:
    :Command:  C-h k
    :Description: Display name and documentation for associated key
    :Context:  anywhere
    :END:
*** view-lossage                                          :window:helps:keys:
    :PROPERTIES:
    :Command:  C-h l
    :Description: Display a description of last 300 keystrokes
    :Context:  anywhere
    :END:
*** describe-mode                                         :window:mode:helps:
    :PROPERTIES:
    :Command:  C-h m
    :Description: Display documentation of current major and minor modes
    :Context:  anywhere
    :END:
*** view-emacs-news                                           :buffer:inform:
    :PROPERTIES:
    :Command:  C-h n
    :Description: Display news of recent Emacs changes
    :Context:  anywhere
    :END:
*** describe-symbol                                            :window:helps:
    :PROPERTIES:
    :Command:  C-h o
    :Description: Display documentation of Lisp symbol provided
    :Context:  anywhere
    :END:
*** finder-by-keyword                                   :window:inform:files:
    :PROPERTIES:
    :Command:  C-h p
    :Description: Find packages by topic keyword
    :Context:  anywhere
    :END:
*** describe-package                                     :window:helps:files:
    :PROPERTIES:
    :Command:  C-h P
    :Description: Display documentation about the specified package
    :Context:  navigating
    :END:
*** info-emacs-manual                                         :buffer:inform:
    :PROPERTIES:
    :Command:  C-h r
    :Description: Display the Emacs manual in Info
    :Context:  anywhere
    :END:
*** describe-syntax                                       :window:helps:char:
    :PROPERTIES:
    :Command:  C-h s
    :Description: Display the contents of the current syntax table
    :Context:  anywhere
    :END:
*** help-with-tutorial                          :buffer:startup:keys:command:
    :PROPERTIES:
    :Command:  C-h t
    :Description: Enter the Emacs interactive tutorial
    :Context:  anywhere
    :END:
*** describe-variable                                          :window:helps:
    :PROPERTIES:
    :Command:  C-h v
    :Description: Display the documentation of the Lisp variable provided
    :Context:  anywhere
    :END:
*** where-is                                              :echo:keys:command:
    :PROPERTIES:
    :Command:  C-h w
    :Description: Show which keys run the command provided
    :Context:  anywhere
    :END:
*** describe-coding-system                              :window:helps:coding:
    :PROPERTIES:
    :Command:  C-h C
    :Description: Describe the coding system provided
    :Context:  navigating
    :END:
*** Info-goto-emacs-command-node                      :buffer:inform:command:
    :PROPERTIES:
    :Command:  C-h F
    :Description: Enter Info at node that describes command provided
    :Context:  navigating
    :END:
*** describe-input-method                                      :window:helps:
    :PROPERTIES:
    :Command:  C-h I
    :Description: Describe the input method provided
    :Context:  anywhere
    :END:
*** Info-goto-emacs-key-command-node             :buffer:inform:command:keys:
    :PROPERTIES:
    :Command:  C-h K
    :Description: Enter Info at node that documents provided key sequence
    :Context:  anywhere
    :END:
*** describe-language-environment                              :window:helps:
    :PROPERTIES:
    :Command:  C-h L
    :Description: Display information of language environment provided
    :Context:  navigating
    :END:
*** info-lookup-symbol                                        :window:inform:
    :PROPERTIES:
    :Command:  C-h S
    :Description: Display the info documentation on provided symbol in context
    :Context:  navigating
    :END:
*** display-local-help                                          :echo:inform:
    :PROPERTIES:
    :Command:  C-h .
    :Description: Display the help message for selected special text area
    :Context:  special-text
    :END:
*** apropos                                            :window:inform:search:
    :PROPERTIES:
    :Description: Search for functions and variables
    :Context:  navigating
    :END:
*** apropos-user-option                                :window:inform:search:
    :PROPERTIES:
    :Description: Search for user-customizable variables
    :Context:  navigating
    :Argument: plain
    :END:
    With a prefix argument, search for non-customizable variables
    too.
*** apropos-variable                                   :window:inform:search:
    :PROPERTIES:
    :Description: Search for variables
    :Context:  navigating
    :Argument: plain
    :END:
    With a prefix argument, search for customizable variables only.
*** apropos-local-variable                             :window:inform:search:
    :PROPERTIES:
    :Description: Search for buffer-local variables
    :Context:  navigating
    :END:
*** apropos-value                                      :window:inform:search:
    :PROPERTIES:
    :Description: Search variables whose values match specified pattern
    :Context:  navigating
    :Argument: plain
    :END:
    With a prefix argument, search also for functions with definitions
    matching the pattern, and Lisp symbols with properties matching
    the pattern.
*** apropos-local-value                                :window:inform:search:
    :PROPERTIES:
    :Description: Search buffer-local variables that match specified pattern
    :Context:  navigating
    :END:
*** forward-button                                         :nav:helps:buffer:
    :PROPERTIES:
    :Command:  <TAB>
    :Description: Move point forward to the next hyperlink
    :Context:  help
    :END:
*** backward-button                                        :nav:helps:buffer:
    :PROPERTIES:
    :Command:  S-<TAB>
    :Description: Move point back to the previous hyperlink
    :Context:  help
    :END:
*** help-follow-symbol                                         :helps:buffer:
    :PROPERTIES:
    :Command:  C-c C-c
    :Description: Show all documentation about the symbol at point
    :Context:  help
    :END:
*** help-go-forward                                        :nav:buffer:helps:
    :PROPERTIES:
    :Command:  C-c C-f OR r
    :Description: Go forward to the next help topic
    :Context:  help
    :END:
*** help-go-back                                           :nav:buffer:helps:
    :PROPERTIES:
    :Command:  C-c C-b OR l
    :Description: Go back to the previous help topic
    :Context:  help
    :END:
*** describe-copying                                          :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-c
    :Description: Display the rules under which you can copy Emacs
    :Context:  anywhere
    :END:
*** view-emacs-debugging                                      :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-d
    :Description: Display help for debugging Emacs
    :Context:  anywhere
    :END:
*** view-external-packages                                    :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-e
    :Description: Display information about where to get external packages
    :Context:  anywhere
    :END:
*** describe-gnu-project                                       :frame:inform:
    :PROPERTIES:
    :Command:  C-h g
    :Description: Visit the page with information about the GNU Project
    :Context:  anywhere
    :END:
*** view-order-manuals                                        :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-m
    :Description: Display info on printed copies of Emacs manuals
    :Context:  anywhere
    :END:
*** describe-distribution                                     :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-o
    :Description: Display how to download latest version of Emacs
    :Context:  anywhere
    :END:
*** view-emacs-problems                                       :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-p
    :Description: Display known Emacs problems, sometimes with workaround
    :Context:  anywhere
    :END:
*** view-emacs-todo                                           :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-t
    :Description: Display the Emacs to-do list
    :Context:  anywhere
    :END:
*** describe-no-warranty                                      :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-w
    :Description: Display full details on no warranty for GNU Emacs
    :Context:  anywhere
    :END:
** The Mark and the Region
*** set-mark-command                                          :buffer:region:
    :PROPERTIES:
    :Command:  C-<SPC> OR C-@
    :Description: Set the mark at point, and activate it
    :Context:  anywhere
    :Argument: plain
    :END:
    With plain prefix argument, move point to where the previous mark
    was, and restore the mark from the ring of former marks.
*** exchange-point-and-mark                               :buffer:region:nav:
    :PROPERTIES:
    :Command:  C-x C-x
    :Description: Swap mark and point and activate mark
    :Context:  anywhere
    :Argument: plain
    :END:
    If you call this with a plain prefix argument, it leaves the mark
    inactive and the region unhighlighted; you can use this to jump to
    the mark in a manner similar to ~C-u C-<SPC>~.
*** mouse-set-region                                      :buffer:region:nav:
    :PROPERTIES:
    :Command:  <drag-mouse-1>
    :Description: Set point and the mark around the text you drag across.
    :Context:  anywhere
    :END:
*** mouse-save-then-kill                                  :buffer:region:nav:
    :PROPERTIES:
    :Command:  <mouse-3>
    :Description: Set the mark at point, then move point to click
    :Context:  anywhere
    :END:
*** upcase-region                                        :buffer:region:edit:
    :PROPERTIES:
    :Command:  C-x C-u
    :Description: Convert text in active region to upcase, deactivate mark
    :Context:  editing
    :END:
*** mark-word                                            :buffer:region:word:
    :PROPERTIES:
    :Command:  M-@
    :Description: Set mark at the end of the next word
    :Context:  anywhere
    :Argument: numeric
    :END:
    This command also accepts a numeric argument /n/, which tells it
    to advance the mark by /n/ words. A negative argument -/n/ moves
    the mark back by /n/ words.
*** mark-sexp                                            :buffer:region:word:
    :PROPERTIES:
    :Command:  C-M-<SPC> OR C-M-@
    :Description: Set mark after end of following balanced expression
    :Context:  anywhere
    :Argument: numeric
    :END:
    Positive or negative numeric arguments move the mark forward or
    backward by the specified number of expressions.
*** mark-paragraph                                   :buffer:region:line:nav:
    :PROPERTIES:
    :Command:  M-h
    :Description: Move point to start of paragraph, set mark at end
    :Context:  anywhere
    :Argument: numeric
    :END:
    numeric arguments specify how many objects to move the mark by.
*** mark-defun                                       :buffer:region:line:nav:
    :PROPERTIES:
    :Command:  C-M-h
    :Description: Move point to start of current defun, set mark at end
    :Context:  anywhere
    :Argument: numeric
    :END:
    Numeric arguments specify how many objects to move the mark by.
*** mark-page                                             :buffer:region:nav:
    :PROPERTIES:
    :Command:  C-x C-p
    :Description: Move point to start of page, set mark at end
    :Context:  anywhere
    :Argument: numeric
    :END:
    Numeric arguments specify how many objects to move the mark by.
*** mark-whole-buffer                                     :buffer:region:nav:
    :PROPERTIES:
    :Command:  C-x h
    :Description: Move point to start of buffer, set mark at end
    :Context:  anywhere
    :Argument: numeric
    :END:
    Numeric arguments specify how many objects to move the mark by.
*** kill-region                                     :kill:region:edit:delete:
    :PROPERTIES:
    :Command:  C-w
    :Description: Kill ("cut") text between point and mark
    :Context:  editing
    :END:
*** kill-ring-save                                              :kill:region:
    :PROPERTIES:
    :Command:  M-w
    :Description: Save the region as if killed, but don't kill it. ("Copy")
    :Context:  navigating
    :END:
*** downcase-region                                             :edit:region:
    :PROPERTIES:
    :Command:  C-x C-l
    :Description: Convert the region to lower case
    :Context:  editing
    :END:
*** upcase-region                                               :edit:region:
    :PROPERTIES:
    :Command:  C-x C-u
    :Description: Convert the region to upper case
    :Context:  editing
    :END:
*** query-replace                                               :edit:search:
    :PROPERTIES:
    :Command:  M-%
    :Description: Replace some occurrences of one string with another
    :Context:  editing
    :END:
*** indent-rigidly                                         :edit:line:region:
    :PROPERTIES:
    :Command:  C-x <TAB>
    :Description: Indent all lines starting in the region
    :Context:  editing
    :END:
*** indent-region                                          :edit:line:region:
    :PROPERTIES:
    :Command:  C-M-\
    :Description: Indent each nonblank line in the region
    :Context:  editing
    :END:
*** fill-region                                                 :edit:region:
    :PROPERTIES:
    :Description: Fill each of the paragraphs in the region
    :Context:  editing
    :END:
*** ispell-word                                                   :word:edit:
    :PROPERTIES:
    :Command:  M-$
    :Description: Check spelling of word under or before the cursor
    :Context:  editing
    :END:
*** eval-region                                                     :command:
    :PROPERTIES:
    :Description: Execute the region as Lisp code
    :Context:  anywhere
    :END:
*** copy-to-register                                                 :region:
    :PROPERTIES:
    :Command:  C-x r x OR C-x r s
    :Description: Copy region into given register
    :Context:  navigating
    :END:
*** delete-selection-mode                           :mode:delete:edit:region:
    :PROPERTIES:
    :Description: Toggle Delete Selection mode
    :Context:  editing
    :END:
*** pop-global-mark                                       :nav:region:buffer:
    :PROPERTIES:
    :Command:  C-x C-<SPC>
    :Description: Jumps to last buffer and position of global mark ring
    :Context:  navigating
    :END:
*** transient-mark-mode                                  :display:region:nav:
    :PROPERTIES:
    :Description: Toggle Transient Mark mode
    :Context:  navigating
    :END:
** Killing and Moving Text
*** delete-horizontal-space                                     :delete:char:
    :PROPERTIES:
    :Command:  M-\
    :Description: Delete spaces and tabs around point
    :Context:  editing
    :Argument: plain
    :END:
    With a prefix argument, this only deletes spaces and tab
    characters before point.
*** just-one-space                                              :delete:char:
    :PROPERTIES:
    :Command:  M-<SPC>
    :Description: Delete spaces and tabs around point, leaving one space
    :Context:  editing
    :Argument: numeric
    :END:
    With a numeric argument /n/, it leaves /n/ spaces before point if
    /n/ is positive; if /n/ is negative, it deletes newlines in
    addition to spaces and tabs, leaving /-n/ spaces before point.
*** delete-blank-lines                                          :delete:line:
    :PROPERTIES:
    :Command:  C-x C-o
    :Description: Delete blank lines around the current line
    :Context:  editing
    :END:
    ~C-x C-o~ (~delete-blank-lines~) deletes all blank lines after the
    current line. If the current line is blank, it deletes all blank
    lines preceding the current line as well (leaving one blank line,
    the current line). On a solitary blank line, it deletes that line.
*** delete-indentation                                          :delete:line:
    :PROPERTIES:
    :Command:  M-^
    :Description: Join two lines by deleting newline and indentation
    :Context:  editing
    :END:
*** cycle-spacing                                               :delete:char:
    :PROPERTIES:
    :Description: Manipulate whitespace around point in a smart way
    :Context:  editing
    :END:
    The command ~cycle-spacing~ acts like a more flexible version of
    ~just-one-space~. It does different things if you call it
    repeatedly in succession. The first call acts like
    ~just-one-space~, the next removes all whitespace, and a third
    call restores the original whitespace.
*** delete-duplicate-lines                                      :delete:line:
    :PROPERTIES:
    :Description: Delete all but one copy of any identical lines in the region
    :Context:  editing
    :Argument: plain, double, tripple
    :END:
    - By default keeps first instance of each repeated line
    - With a plain prefix it keeps the last instance of each repeated
      line
    - With a double prefix argument, it only searches for adjacent
      identical lines.
    - With a tripple prefix argument, it retains repeated blank lines
*** kill-whole-line                                        :kill:line:delete:
    :PROPERTIES:
    :Command:  C-S-<DEL>
    :Description: Kill an entire line at once
    :Context:  editing
    :END:
    Note that many text terminals will prevent you from typing the key
    sequence ~C-S-<DEL>~
*** backward-kill-sentence                                      :delete:kill:
    :PROPERTIES:
    :Command:  C-x <DEL>
    :Description: Kill back to the beginning of sentence
    :Context:  editing
    :END:
*** kill-sentence                                               :kill:delete:
    :PROPERTIES:
    :Command:  M-k
    :Description: Kill to the end of the sentence
    :Context:  editing
    :END:
*** kill-sexp                                                   :delete:kill:
    :PROPERTIES:
    :Command:  C-M-k
    :Description: Kill the following balanced expression
    :Context:  editing
    :END:
*** zap-to-char                                            :char:delete:kill:
    :PROPERTIES:
    :Command:  M-z <char>
    :Description: Kill through the next occurrence of <char>
    :Context:  editing
    :Argument: numeric
    :END:
    A numeric argument acts as a repeat count; a negative argument
    means to search backward and kill text before point.
*** yank                                                               :edit:
    :PROPERTIES:
    :Command:  C-y
    :Description: Yank the last kill into the buffer, at point
    :Context:  editing
    :Argument: numeric, plain
    :END:
    Inserts the most recent kill, leaving the cursor at the end of the
    inserted text. It also sets the mark at the beginning of the
    inserted text, without activating the mark.

    With a plain prefix argument (~C-u C-y~), the command instead
    leaves the cursor in front of the inserted text, and sets the mark
    at the end.

    Using a numeric argument /n/ specifies reinserting the /n/-th
    earlier kill. And keeps the last-yank pointer at that kill.
*** yank-pop                                                      :edit:hist:
    :PROPERTIES:
    :Command:  M-y
    :Description: Replace recent yanked text with earlier batch of killed text
    :Context:  editing
    :Argument: numeric
    :END:
    A numeric argument defines how many entries to advance the
    last-yank pointer by. A negative argument moves the pointer toward
    the front of the ring; from the front of the ring, it moves around
    to the last entry and continues forward from there.
*** append-next-kill                                              :kill:hist:
    :PROPERTIES:
    :Command:  C-M-w
    :Description: Cause following kill command to append to previous kill
    :Context:  editing
    :END:
*** set-selection-coding-system                                 :kill:coding:
    :PROPERTIES:
    :Command:  C-x <RET> x
    :Description: set coding system for killed text in clipboard
    :Context:  navigating
    :END:
*** set-next-selection-coding-system                            :kill:coding:
    :PROPERTIES:
    :Command:  C-x <RET> X
    :Description: Use coding-system for only next communication with other apps
    :Context:  navigating
    :END:
*** clipboard-kill-region                                       :kill:delete:
    :PROPERTIES:
    :Command:  <f20>
    :Description: kills the region and saves it to the clipboard
    :Context:  editing
    :END:
*** clipboard-kill-ring-save                                           :kill:
    :PROPERTIES:
    :Command:  <f16>
    :Description: copies region to kill ring and saves to clipboard
    :Context:  navigating
    :END:
*** clipboard-yank                                                     :edit:
    :PROPERTIES:
    :Command:  <f18>
    :Description: yanks the contents of the clipboard at point
    :Context:  editing
    :END:
*** mouse-yank-primary                                                 :edit:
    :PROPERTIES:
    :Command:  <mouse-2>
    :Description: Insert primary selection in Emacs buffer at point or click
    :Context:  editing
    :END:
*** mouse-set-secondary                                              :region:
    :PROPERTIES:
    :Command:  <M-Drag-mouse-1>
    :Description: Set secondary selection within dragged region
    :Context:  navigating
    :END:
    The selected text is highlighted, using the ~secondary-selection~
    face, as you drag. The window scrolls automatically if you drag
    the mouse off the top or bottom of the window, just like
    ~mouse-set-region~.

    This command does not alter the kill ring
*** mouse-start-secondary                                            :region:
    :PROPERTIES:
    :Command:  <M-mouse-1>
    :Description: Set one endpoint for the secondary selection
    :Context:  navigating
    :END:
    Use ~M-mouse-3~ to set the other end and complete the
    selection. This command cancels any existing secondary selection,
    when it starts a new one.

    Double or triple clicking of ~M-mouse-1~ operates on words and
    lines, much like ~mouse-1~.
*** mouse-secondary-save-then-kill                              :region:kill:
    :PROPERTIES:
    :Command:  <M-mouse-3>
    :Description: Set the secondary selection and copy to kill ring
    :Context:  navigating
    :END:
    A second ~M-mouse-3~ at the same place kills the text selected by
    the secondary selection just made.
*** mouse-yank-secondary                                               :edit:
    :PROPERTIES:
    :Command:  <M-mouse-2>
    :Description: Insert secondary selection at point or click
    :Context:  editing
    :END:
    Places point at the end of the yanked text
*** append-to-buffer                                          :region:buffer:
    :PROPERTIES:
    :Description: Append region to the contents of a specified buffer
    :Context:  navigating
    :END:
    This reads a buffer name, then inserts a copy of the region into
    the buffer specified. If you specify a nonexistent buffer, this
    command creates the buffer.

    Point in that buffer is left at the end of the copied text, so
    successive uses of this command accumulate the text in the
    specified buffer in the same order as they were copied. Strictly
    speaking, the command does not always append to the text already
    in the buffer - it appends only if point in that buffer is at the
    end. However, if the command is the only command you use to alter
    a buffer then point is always at the end.
*** prepend-to-buffer                                         :region:buffer:
    :PROPERTIES:
    :Description: Prepend region to the contents of a specified buffer
    :Context:  navigating
    :END:
    This command is just like ~append-to-buffer~ except that point in
    the other buffer is left before the copied text, so successive
    uses of this command add text in reverse order.
*** copy-to-buffer                                     :region:buffer:delete:
    :PROPERTIES:
    :Description: Copy region into specified buffer, deleting the contents
    :Context:  navigating
    :END:
*** insert-buffer                                               :edit:buffer:
    :PROPERTIES:
    :Description: Insert specified buffer into current buffer at point
    :Context:  editing
    :END:
    This prompts for the name of a buffer, and inserts a copy of all
    the text in that buffer into the curreng buffer at point, leaving
    point at the beginning of the inserted text. It also adds the
    position of the end of the inserted text to the mark ring, without
    activating the mark.
*** append-to-file                                             :region:files:
    :PROPERTIES:
    :Description: Append region to contents of specified file, at the end
    :Context:  navigating
    :END:
    This prompts for a filename, and adds the text of the region to
    the end of the specified file. The file is changed immediately on
    disk.

    You should only use this command with files that are /not/ being
    visited in Emacs. Using it on a file that you are editing in Emacs
    would change the file behind Emac's back, which can lead to losing
    some of your editing.
*** kill-rectangle                                       :region:kill:delete:
    :PROPERTIES:
    :Command:  C-x r k
    :Description: Kill text of region-rectangle, save as last killed rectangle
    :Context:  editing
    :END:
*** copy-rectangle-as-kill                                      :region:kill:
    :PROPERTIES:
    :Command:  C-x r M-w
    :Description: Save the text of region-rectangle as last killed rectangle
    :Context:  navigating
    :END:
*** delete-rectangle                                          :region:delete:
    :PROPERTIES:
    :Command:  C-x r d
    :Description: Delete the text of region-rectangle
    :Context:  editing
    :END:
*** yank-rectangle                                              :region:edit:
    :PROPERTIES:
    :Command:  C-x r y
    :Description: Yank last killed rectangle with up left corner at point
    :Context:  editing
    :END:
*** open-rectangle                                              :region:edit:
    :PROPERTIES:
    :Command:  C-x r o
    :Description: Insert blank space to fill region-rectangle, push right
    :Context:  editing
    :END:
*** rectangle-number-lines                                      :region:edit:
    :PROPERTIES:
    :Command:  C-x r N
    :Description: Insert line numbers on left of region-rectangle, push right
    :Context:  editing
    :Argument: numeric
    :END:
    Normally, the numbering begins from 1 (for the first line of the
    rectangle). With a numeric argument, the command prompts for a
    number to begin from, and for a format string with which to print
    the numbers.
*** clear-rectangle                                             :region:edit:
    :PROPERTIES:
    :Command:  C-x r c
    :Description: Clear region-rectangle by replacing contents with spaces
    :Context:  editing
    :END:
*** delete-whitespace-rectangle                               :region:delete:
    :PROPERTIES:
    :Description: Delete whitespace in region-rectangle along left edge
    :Context:  editing
    :END:
    Deletes horizontal whitespace starting from a particular
    column. This applies to each of the lines in the rectangle, and
    the column is specified by the left edge of the rectangle. The
    right edge of the rectangle does not make any difference to this
    command.
*** string-rectangle                                            :region:edit:
    :PROPERTIES:
    :Command:  C-x r t
    :Description: Replace rectangle contents with given string on each line
    :Context:  editing
    :END:
    The string's width need not be the same width of the rectangle. If
    the string's width is less, the text after the rectangle shifts
    left; if the string is wider than the rectangle, the text after
    the rectangle shifts right.
*** string-insert-rectangle                                     :region:edit:
    :PROPERTIES:
    :Description: Insert given string on each line of rectangle
    :Context:  editing
    :END:
*** rectangle-mark-mode                                 :region:display:mode:
    :PROPERTIES:
    :Command:  C-x <SPC>
    :Description: Toggle Rectangle Mark mode
    :Context:  navigating
    :END:
*** rectangle-exchange-point-and-mark                        :region:display:
    :PROPERTIES:
    :Command:  C-x C-x
    :Description: Cycle between four corners of region-rectangle
    :Context:  rectangle
    :END:
*** cua-mode                               :command:keys:mode:edit:kill:undo:
    :PROPERTIES:
    :Description: Toggle CUA mode
    :Context:  navigating
    :END:
*** kill-region                                     :kill:region:edit:delete:
    :PROPERTIES:
    :Command:  C-x <timeout>
    :Description: Kill ("cut") text between point and mark
    :Context:  cua
    :Argument: numeric
    :END:
    With a one digit numeric prefix kill text into that numbered
    register.
*** copy-region-as-kill                                         :kill:region:
    :PROPERTIES:
    :Command:  C-c <timeout>
    :Description: Save the region as if killed, but don't kill it
    :Context:  cua
    :Argument: numeric
    :END:
    With a one digit numeric prefix copy text into that numbered
    register.
*** cua-paste                                                          :edit:
    :PROPERTIES:
    :Command:  C-v
    :Description: Paste last cut or copied region or rectangle
    :Context:  cua
    :Argument: numeric
    :END:
    With a one digit numeric prefix paste text from that numbered
    register.
*** undo                                                               :undo:
    :PROPERTIES:
    :Command:  C-z
    :Description: Undo some previous changes
    :Context:  cua
    :END:
*** cua-set-rectangle-mark                                      :region:mode:
    :PROPERTIES:
    :Command:  C-<RET>
    :Description: Set mark and start in CUA rectangle mode
    :Context:  cua
    :END:
*** cua-rotate-rectangle                                         :region:nav:
    :PROPERTIES:
    :Command:  <RET>
    :Description: Move to next corner of rectangle selection (clockwise)
    :Context:  cua-rectangle
    :END:
*** cua-toggle-global-mark                                             :edit:
    :PROPERTIES:
    :Command:  C-S-<SPC>
    :Description: Set or cancel the global marker
    :Context:  cua
    :END:
** Registers
*** view-register                                     :window:register:helps:
    :PROPERTIES:
    :Description: Display a description of what given register contains
    :Context:  anywhere
    :END:
    test
*** Display Available Registers                  :window:register:char:helps:
    :PROPERTIES:
    :Command:  C-h OR <F1>
    :Description: Explicitly request to preview available registers
    :Context:  register
    :END:
*** point-to-register                                   :register:nav:buffer:
    :PROPERTIES:
    :Command:  C-x r <SPC>
    :Description: Record current buffer and position in given register
    :Context:  navigating
    :END:
*** jump-to-register                                    :register:nav:buffer:
    :PROPERTIES:
    :Command:  C-x r j
    :Description: Restore state saved in given register
    :Context:  anywhere
    :Argument: plain
    :END:
    If given register stored a position in a buffer then this command
    jumps to saved position and buffer in given register.
    
    If you use this command to go to a saved position, but the buffer
    it was saved from has been killed, the command tries to create the
    buffer again by visiting the same file. Of course, this works only
    for buffers that were visiting files.

    If given register stored a window configuration then using this
    command restores the window configuration. When you restore a
    frame configuration, any existing frames not included in the
    configuration become invisible.

    If given register stored a window configuration then with a plain
    argument this command will delete any frames that are not included
    in the configuration.

    If given register stored a complete filename with path then this
    command visits that file.

    If given register stored a keyboard macro this command executes
    the keyboard macro.
*** copy-to-register                                        :region:register:
    :PROPERTIES:
    :Command:  C-x r s
    :Description: Copy region into given register
    :Context:  navigating
    :Argument: plain
    :END:
    If the mark is inactive, Emacs first reactivates the mark where it
    was last set. The mark is deactivated at the end of this command.

    With a plain argument this command copies the text into given
    register and deletes the text from the buffer as well.
*** insert-register                                    :region:register:edit:
    :PROPERTIES:
    :Command:  C-x r i
    :Description: Insert contents from given register at point
    :Context:  editing
    :Argument: plain
    :END:
    Normally this leaves point after the text and sets the mark
    before, without activating it.

    With a prefix argument, it instead puts point before the text and
    the mark after.

    Will insert rectangle if given register contains a rectangle.

    When contents of register is a number, will insert number from
    given register at point.
*** append-to-register                                      :region:register:
    :PROPERTIES:
    :Description: Append region to text in given register
    :Context:  navigating
    :Argument: plain
    :END:
    If invoked with a plain argument, it deletes the region after
    appending it to the register.
*** increment-register                                             :register:
    :PROPERTIES:
    :Command:  C-x r +
    :Description: Behaves different depending on contents of register
    :Context:  anywhere
    :Argument: numeric
    :END:
    When given register contains text, this command appends text in
    region to that register.

    When given register contains a number, this command increases that
    number by 1.

    With a numeric argument, when the register contains a number, this
    adds the number in the register with the numeric argument and
    stores the sum in the register.
*** prepend-to-register                                     :region:register:
    :PROPERTIES:
    :Description: Prepend region to text in given register
    :Context:  navigating
    :Argument: plain
    :END:
    If invoked with a prefix argument, it deletes the region after
    prepending it to the given register.
*** copy-rectangle-to-register                              :region:register:
    :PROPERTIES:
    :Command:  C-x r r
    :Description: Copy region-rectangle into given register
    :Context:  navigating
    :Argument: plain
    :END:
    With a plain argument, delete the rectangle in addition to copying
    the rectangle to the given register.
*** window-configuration-to-register                  :window:frame:register:
    :PROPERTIES:
    :Command:  C-x r w
    :Description: Save state of selected frame's windows in given register
    :Context:  anywhere
    :END:
*** frameset-to-register                              :window:frame:register:
    :PROPERTIES:
    :Command:  C-x r f
    :Description: Save state of all frames, all windows, in given register
    :Context:  anywhere
    :END:
*** number-to-register                                             :register:
    :PROPERTIES:
    :Command:  C-x r n
    :Description: Store number 0 in given register
    :Context:  anywhere
    :Argument: numeric
    :END:
    With a numeric argument store that number into the given
    register.
*** kmacro-to-register                                       :macro:register:
    :PROPERTIES:
    :Command:  C-x C-k x
    :Description: Stores the last keyboard macro in given register
    :Context:  anywhere
    :END:
*** bookmark-set                                                 :buffer:nav:
    :PROPERTIES:
    :Command:  C-x r m
    :Description: Set the bookmark named with given name at point
    :Context:  navigating
    :END:
    Default name for bookmark is the file name.
*** bookmark-set-no-overwrite                                    :buffer:nav:
    :PROPERTIES:
    :Command:  C-x r M
    :Description: set bookmark without overwriting existing bookmark
    :Context:  navigating
    :END:
    Displays error if attempting to overwrite an existing bookmark
*** bookmark-jump                                                :buffer:nav:
    :PROPERTIES:
    :Command:  C-x r b
    :Description: Jump to bookmark with given name
    :Context:  anywhere
    :END:
*** list-bookmarks                                          :buffer:list:nav:
    :PROPERTIES:
    :Command:  C-x r l
    :Description: List all bookmarks
    :Context:  anywhere
    :END:
*** bookmark-save                                          :files:nav:buffer:
    :PROPERTIES:
    :Description: Save all current bookmark values in default bookmark file
    :Context:  anywhere
    :END:
*** bookmark-load                                          :buffer:nav:files:
    :PROPERTIES:
    :Description: Load file with given name containing bookmarks
    :Context:  anywhere
    :END:
    You can use this command to work with other files of bookmark
    values in addition to your default bookmark file.
*** bookmark-write                                         :buffer:nav:files:
    :PROPERTIES:
    :Description: Save all current bookmark values in given file
    :Context:  anywhere
    :END:
*** bookmark-delete                                       :buffer:nav:delete:
    :PROPERTIES:
    :Description: Delete bookmark with given name
    :Context:  anywhere
    :END:
*** bookmark-insert-location                          :buffer:nav:files:edit:
    :PROPERTIES:
    :Description: Insert in buffer the filename pointed to by given bookmark
    :Context:  editing
    :END:
*** bookmark-insert                                         :buffer:nav:edit:
    :PROPERTIES:
    :Description: Insert in buffer the content that given bookmark points to
    :Context:  editing
    :END:
** Controlling the Display
*** scroll-up                                                   :display:nav:
    :PROPERTIES:
    :Description: Like ~C-v~ but disobeys ~scroll-error-top-bottom~
    :Context:  navigating
    :END:
*** scroll-down                                                 :display:nav:
    :PROPERTIES:
    :Description: Like ~M-v~ but disobeys ~scroll-error-top-bottom~
    :END:
*** scroll-up-line                                              :display:nav:
    :PROPERTIES:
    :Description: Scroll the current window up by one line at a time
    :Context:  navigating
    :END:
*** scroll-down-line                                            :display:nav:
    :PROPERTIES:
    :Description: Scroll current window down by one line at a time
    :Context:  navigating
    :END:
*** recenter-top-bottom                                         :display:nav:
    :PROPERTIES:
    :Command:  C-l
    :Description: Scroll selected window so current line is center
    :Context:  navigating
    :Argument: numeric, plain
    :END:
    On subsequent consecutive invocations, make the current line the
    top line, the bottom line, and so on in cyclic order. Possibly
    redisplay the screen too.

    With a plain prefix argument, the command simply recenters the
    line showing point.

    A positive argument /n/ moves the line showing point /n/ lines
    down from the top of the window. An argument of zero moves point's
    line to the top of the window. A negative argument /-n/ moves
    point's line /n/ lines from the bottom of the window.

    When given an argument, the command does not clear the screen or
    cycle through different screen positions
*** recenter                                                    :display:nav:
    :PROPERTIES:
    :Description: Scroll selected window so current line is center
    :Context:  navigating
    :END:
    Possibly redisplay the screen too.
*** reposition-window                                           :display:nav:
    :PROPERTIES:
    :Command:  C-M-l
    :Description: Scroll heuristically to bring useful information on screen
    :Context:  navigating
    :END:
*** scroll-left                                                 :display:nav:
    :PROPERTIES:
    :Command:  C-x <
    :Description: Scroll text in current window to the left
    :Context:  navigating
    :Argument: numeric
    :END:
    scrolls text in the selected window to the left by the full width
    of the window, less two columns. (In other words, the text in the
    window moves left relative to the window.) with a numeric argument
    /n/, it scrolls by /n/ columns.

    If the text is scrolled to the left, and point moves off the left
    edge of the window, the cursor will freeze at the left edge of the
    window, the cursor will freeze at the left edge of the window,
    until point moves back to the displayed portion of the text. This
    is independent of the current setting of ~auto-hscroll-mode~,
    which for text scrolled to the left, only affects the behavior at
    the right edge of the window.
*** scroll-right                                                :display:nav:
    :PROPERTIES:
    :Command:  C-x >
    :Description: Scroll to the right
    :Context:  navigating
    :Argument: numeric
    :END:
    Scrolls similarly as ~scroll-left~ but to the right. The window
    cannot be scrolled any farther to the right once it is displayed
    normally, with each line starting at the window's left margin;
    attmpeting to do so has no effect. This means that you don't have
    to calculate the numeric argument precisely for this command; any
    sufficiently large argument will restpore the normal display.
* Variable
** The Organization of the Screen
*** tty-menu-open-use-ttm                                              :menu:
    when invoking ~menu-bar-open~ invoke ~tmm-menubar~ instead.
** Entering Emacs
*** inhibit-startup-screen                                   :startup:buffer:
    If one or more files were specified on the command line, Emacs
    simply displays those files; otherwise, it displays a buffer named
    ~*scratch*~, which can be used to evaluate Emacs Lisp expressions
    interactively.
*** initial-buffer-choice                                    :startup:buffer:
    Force Emacs to display a file or directory at startup, according
    to filename, directory, or zero (0) argument Lisp Function that
    returns a buffer.
** Exiting Emacs
*** confirm-kill-emacs                                           :kill:frame:
    function to run before killing Emacs. If result of function is
    non-nil, the session is killed, otherwise Emacs continues to run.
*** confirm-kill-processes                                             :kill:
    If nil, does not ask for confirmation before killing sub-processes
    started by Emacs. ~t~ by default.
** Basic Editing Commands
*** read-quoted-char-radix                                        :edit:char:
    To use decimal or hexadecimal when running ~quoted-insert~
    command.
*** line-move-visual                                             :nav:window:
    You can force navigating up and down by line to move according to
    logical lines (i.e., according to the text lines in the buffer) by
    setting this variable to ~nil~.
*** track-eol                                                    :nav:buffer:
    When ~line-move-visual~ is nil, you can set this variable to a
    non-nil value. Then ~C-n~ and ~C-p~, when starting at the end of
    the logical line, move to the end of the next logical
    line. Default is ~nil~.
*** next-line-add-newlines                                  :nav:edit:buffer:
    If you set this variable to a non-nil value, C-n on the last line
    of a buffer creates an additional line at the end and moves down
    into it.
** The Minibuffer
*** minibuffer-eldef-shorten-default                    :buffer:display:echo:
    with a non-nil value, the default argument is displayed as
    ~[default-arg]~ instead of ~(default /default-arg/)~, saving some
    screen space.
*** insert-default-directory                            :buffer:display:echo:
    To prevent Emacs from inserting the default directory when reading
    file names, change this variable to ~nil~. Relative file name
    arguments are still interpreted based on the same default
    directory.
*** resize-mini-windows                                 :buffer:display:echo:
    There are three possible values
    - nil :: Do not resize minibuffer in Echo Area.
    - grow-only :: Grow minibuffer when there is enough text to be
      displayed on a new line. Do not ever shrink minibuffer
    - t :: Grow minibuffer when there is enough text to be displayed
      on a new line. Shrink when text can be displayed on fewer lines
*** max-mini-window-height                              :buffer:display:echo:
    This variable controls the maximum height for resizing the
    minibuffer window. A floating-point number specifies a fraction of
    the frame's height; an integer specifies the maximum number of
    lines; ~nil~ means do not resize the minibuffer window
    automatically. The default value is ~0.25~.
*** enable-recursive-minibuffers                        :buffer:command:echo:
    Emacs normally disallows most commands that use the minibuffer
    while the minibuffer is active. To allow such commands in the
    minibuffer, set this variable to ~t~.
*** confirm-nonexistent-file-or-buffer                  :buffer:command:echo:
    Changes behavior of "Permissive Completion with Confirmation"
    described in [[Completion Exit]]. Three possible values.
    - ~after-completion~ :: Default value. Behaves exactly as
      described in linked section.
    - ~nil~ :: No longer asks for confirmation. Same behavior as
      "Permissive Completion"
    - [other] :: Always asks for confirmation.
*** completion-styles                                         :list:complete:
    See current list and list options defined in:
    [[How Completion Alternatives Are Chosen]]
*** read-file-name-completion-ignore-case        :files:complete:buffer:echo:
    When completing file names, case differences are ignored if this
    variable is non-nil. The default value is nil on systems that have
    case-sensitive file-names, such as GNU/Linux; it is non-nil on
    systems that have case-insensitive file-names, such as Microsoft
    Windows.
*** read-buffer-completion-ignore-case                 :buffer:complete:echo:
    When completing buffer names, case differences are ignored if this
    variable is non-nil; the default is nil.
*** completion-ignored-extensions           :files:complete:list:buffer:echo:
    When completing file names, Emacs usually omits certain
    alternatives that are considered unlikely to be chosen, as
    determined by the values on this list variable. If /all/ possible
    completions end in otherwise-ignored strings, they are not
    ignored. Emacs disregards this variable when showing completion
    alternatives in the completion list.
*** completion-auto-help                  :complete:inform:helps:buffer:echo:
    If this variable is set to ~nil~, the completion commands never
    display the completion list buffer; you must type ~?~ to display
    the list. If the value is ~lazy~, Emacs only shows the completion
    list buffer on the second attempt to complete. In other words, if
    there is nothing to complete, the first <TAB> echos 'Next char not
    unique'; the second <TAB> shows the completion list buffer.
*** completion-cycle-threshold            :complete:inform:helps:buffer:echo:
    If this variable is non-nil, completion commands can cycle through
    completion alternatives. Normally when the variable is ~nil~, if
    there is more than one completion alternative for the text in the
    minibuffer, a completion command completes up to the longest
    common sub-string. If you change this variable to ~t~, the
    completion command instead completes to the first of those
    completion alternatives; each subsequent invocation of the
    completion command replaces that with the next completion
    alternative, in a cyclic manner. If you give this variable a
    number value /n/, completion commands switch to this cycling
    behavior only when there are /n/ or fewer alternatives.
*** history-length                                         :buffer:hist:echo:
    This variable specifies the maximum length of a minibuffer history
    list; adding a new element deletes the oldest element if the list
    gets too long. If the value is ~t~, there is no maximum length.
*** history-delete-duplicates                                          :hist:
    This variable specifies whether to delete duplicates in
    history. If it is non-nil, adding a new element deletes from the
    list all other elements that are equal to it. The default is
    ~nil~.
*** isearch-resume-in-command-history                          :command:hist:
    You can make incremental search commands appear in the history by
    setting this variable to a non-nil value.
*** command-history                                       :command:hist:list:
    The list of previous minibuffer-using commands is stored as a Lisp
    list in this variable.
** Running Commands by Name
*** suggest-key-bindings                                :inform:command:keys:
    When the command you run with ~M-x~ has a key binding, Emacs
    mentions this in the echo area after running the command. You can
    turn off these messages by setting this variable to ~nil~. The
    value can also be a number, in which case Emacs will show the
    binding for that many seconds before removing it from display. The
    default value is ~2~.
*** extended-command-suggest-shorter                         :inform:command:
    Commands that don't have key bindings can still be invoked after
    typing less than their full name at the ~M-x~ prompt. Emacs
    mentions such shorthands in the echo area if they are
    significantly shorter than the full command name, and this
    variable is non-nil. These suggestions won't get shown at all if
    [[suggest-key-bindings]] is ~nil~.
** Help
*** apropos-do-all                                           :search:command:
    If this variable is non-nil, most apropos commands behave as if
    they had been given a prefix argument. There is one exception:
    ~apropos-variable~ without a prefix argument will always search
    for all variables, no matter what the value of this variable is.
*** apropos-sort-by-scores                                   :search:display:
    If this variable is non-nil, apropos commands try to guess the
    relevance of each result, and display the most relevant ones
    first. This variable does not affect how ~apropos-documentation~
    is sorted.
*** apropos-documentation-sort-by-scores                     :search:display:
    To list the results of ~apropos-documentation~ in alphabetical
    order, change this variable to nil.
*** help-at-pt-display-when-idle                   :word:inform:display:echo:
    To display help text automatically whenever it is available at
    point, set this variable to t.
** The Mark and the Region
*** highlight-nonselected-windows                     :display:region:window:
    Ordinarily, only the selected window highlights its region;
    however, if this variable is non-nil, each window highlights its
    own region.
*** use-empty-active-region                                  :region:command:
    If you want region specific commands to perate on the empty
    region, change this variable to ~t~.
*** delete-active-region                            :region:edit:delete:kill:
    If you change this variable to ~nil~, then ~<DEL>~ and ~<Delete>~
    don't act differently when the mark is active. If you change the
    value to ~kill~, these commands kill the region instead of
    deleting it.
*** mark-even-if-inactive                                    :region:command:
    By default, if the mark is inactive, region only commands operate
    on the inactive region - that is, on the text between point and
    the position at which the mark was last set. To disable this
    behavior, change this variable to ~nil~. Then these commands will
    instead signal an error if the mark is inactive.
*** set-mark-command-repeat-pop                        :nav:region:keys:hist:
    If you set this variable to non-nil, then immediately after you
    type ~C-u C-<SPC>~, you can type ~C-<SPC>~ instead of
    ~C-u C-<SPC>~ to cycle through the mark ring. By default,
    ~set-mark-command-repeat-pop~ is ~nil~.
*** mark-ring-max                                               :region:hist:
    This variable specifies the maximum number of entries to keep in
    the mark ring. This defaults to 16 entries. If that many entries
    exist and another one is pushed, the earliest one in the list is
    discarded. Repeating ~C-u C-<SPC>~ cycles through the positions
    currently in the ring.
*** global-mark-ring-max                                        :region:hist:
    The length of the global mark ring is controlled by this variable,
    and is 16 by default.
*** shift-select-mode                                       :nav:region:mode:
    Variable determining whether or not Shift Select mode is active/on
    or not. To turn off set this variable to ~nil~.
** Killing and Moving Text
*** kill-whole-line                                        :kill:delete:line:
    If this variable is non-nil, ~C-k~ at the very beginning of a line
    kills the entire line including the following newline. The
    variable is normally ~nil~.
*** kill-read-only-ok                                                  :kill:
    Normally, using a kill command in a read only buffer causes Emacs
    to beep and display an error message, but if you set this variable
    to a non-nil value, they just print a message in the echo area to
    explain why the text has not been erased.
*** kill-do-not-save-duplicates                                   :kill:hist:
    If you change this vairable to a non-nil value, identical
    subsequent kills yield a single kill-ring entry, without
    duplication.
*** kill-ring-max                                                 :kill:hist:
    The maximum number of entries in the kill ring is controlled by
    this variable. The default is 60.
*** kill-ring                                                     :kill:hist:
    The actual contents of the kill ring are stored in this variable.
*** x-select-request-type                                       :kill:coding:
    You can request a different data type to copy to clipboard by
    customizing this variable
*** save-interprogram-paste-before-kill                           :kill:hist:
    Optionally, you can change this variable to ~t~. Then Emacs will
    first save the clipboard to its kill ring before using a kill
    command, preventing you from losing the old clipboard data - at
    the risk of high memory consumption if that data turns out to be
    large.
*** yank-pop-change-selection                                     :kill:hist:
    Normally rotating the kill ring with ~M-y~ (~yank-pop~) does not
    alter the clipboard. However, if you change this variable to ~t~,
    then ~M-y~ saves the new yank to the clipboard.
*** select-enable-clipboard                                            :kill:
    To prevent kill and yank commands from accessing the clipboard,
    change this variable to ~nil~.
*** x-select-enable-clipboard-manager                                  :kill:
    If you exit Emacs while it is the current "owner" of the clipboard
    data, and there is a clipboard manager running, Emacs transfers
    the clipboard data to the clipboard manager so that it is not
    lost. In some circumstances, this may cause a delay when exiting
    Emacs; if you wish to prevent Emacs from transferring data to the
    clipboard manager, change this variable to ~nil~.
*** select-enable-clipboard                                            :kill:
    Non-nil means cutting and pasting uses the clipboard. This can be
    in addition to, but in preference to, the primary selection, if
    applicable.
*** select-enable-primary                                              :kill:
    Non-nil means cutting and pasting uses the primary selection. The
    esistence of a primary selection depends on the underlying GUI you
    use. E.g. it doesn't exist under MS-Windows.
*** mouse-drag-copy-region                                      :kill:region:
    If non-nil, copy to kill-ring upon mouse adjustments of the
    region.
*** select-active-regions                                            :region:
    If you change this variable to ~only~, Emacs saves only temprarily
    active regions to the primary selection, i.e., those made with the
    mouse or with shift selection. If you change this variable to
    ~nil~, Emacs avoids saving active regions to the primary selection
    entirely.
*** mouse-yank-at-point                                                :edit:
    If this variable is non-nil, ~M-mouse-2~ yanks at point. Then it
    does not matter precisely where you click, or even which of the
    frame's windows you click on.
*** cua-enable-cua-keys                          :region:display:edit:delete:
    To disable the overriding of standard Emacs binding by CUA mode,
    while retaining the other features of CUA mode described in the
    mode, set this variable to ~nil~.
*** cua-delete-selection                                      :delete:region:
    To use CUA mode without activating Delete-Selection mode set this
    variable to ~nil~.
** Registers
*** register-preview-delay                     :register:command:echo:window:
    All commands that prompt for a register will display a preview
    window that lists the existing registers (if there are any) after
    a short delay. To change the length of the delay, customize this
    variable. To prevent this display, set this variable to ~nil~.
*** register-separator                                             :register:
    This variable stores which register should be considered the
    ~register-separator~ register and then will use the contents of
    this register to put in between text inserted into any other
    register using the commands either ~append-to-register~ or
    ~prepend-to-register~. By default the register ~+~ is used.

    When this variable is set to ~nil~ no extra text will be put in
    between text when using the previously mentioned commands.
*** bookmark-save-flag                                     :files:nav:buffer:
    If you set this variable to ~1~, each command that sets a bookmark
    will also save your bookmarks; this way, you don't lose any
    bookmark values even if Emacs crashes. The value, if a number,
    says how many bookmark modifications should go by between
    saving. If you set this variable to ~nil~, Emacs only saves
    bookmarks if you explicitly use ~bookmark-save~. Default value is
    ~t~ which means bookmarks save when Emacs is killed.
*** bookmark-default-file                                  :files:nav:buffer:
    The value of this variable specifies the file in which to save
    bookmarks by default.
*** bookmark-search-size                                    :buffer:hist:nav:
    This variable says how many characters of context to record on
    each side of the bookmark's position.
** Controlling the Display
*** next-screen-context-lines                                   :display:nav:
    The number of lines of overlap left by the commands
    ~scroll-up-command~ and ~scroll-down-command~ is controlled by
    this variable, whose default value is 2.
*** scroll-error-top-bottom                                     :display:nav:
    By default, the commands ~scroll-up-command~ and
    ~scroll-down-command~ signal an error (by beeping or flashing the
    screen) if no more scrolling is possible, because the window has
    reached the beginning or end of the buffer. If you change this
    variable to ~t~, these commands move point to the farthest
    possible position. If point is already there, the commands signal
    an error.
*** scroll-preserve-screen-position                             :display:nav:
    If the value is ~t~, Emacs adjusts point to keep the cursor at the
    same screen position whenever a scroll command moves it
    off-window, rather than moving it to the topmost or bottommost
    line. With any other non-nil value, emacs adjusts point this way
    even if the scroll command leaves point in the window. This
    variable affects all scroll commands in the section named
    [[Controlling the Display]], as well as scrolling with the mouse
    wheel; in general, it affects any command that has a non-nil
    ~scroll-command~ property.
*** recenter-positions                      :list:window:display:nav:command:
    You can change the cycling order of the command
    ~recenter-top-bottom~ by customizing this list variable. Each list
    element should be the symbol ~top~, ~middle~, or ~bottom~, or a
    number; an integer means to move the line to the specified screen
    line, while a floating point number between 0.0 and 1.0 specifies
    a percentage of the screen space from the top of the window. The
    default, ~(middle top bottom)~, is the cycling order described in
    the documentation of ~recenter-top-bottom~.
*** scroll-margin                                        :window:display:nav:
    If you change this variable to a non-zero value /n/, then
    ~recenter-top-bottom~ always leaves at least /n/ screen lines
    between point and the top or bottom of the window.
*** recenter-redisplay                                       :display:window:
    If this variable has a non-nil value, each invocation of
    ~recenter-top-bottom~ also clears and redisplays the screen; The
    special value ~tty~ (the default) says to do this on text-terminal
    frames only.
*** scroll-conservitavely                                    :display:window:
    If you set this variable to a small number /n/, then moving point
    just a little off screen (no more than /n/ lines) causes Emacs to
    scroll just enough to bring point back on screen; If doing so
    fails to make point visible, Emacs scrolls just far enough to
    center point in the window. If you set this variable to a large
    number (larger than 100), automatic scrolling never centers point,
    no matter how far point moves; Emacs always scrolls text just
    enough to bring point into view, either at the top or bottom of
    the window depending on the scroll direction. By default, the
    variable is 0, which means to always center point in the window.
*** scroll-step                                              :display:window:
    The value of this valuable determines the number of lines by which
    to automatically scroll, when point moves off the screen. If
    scrolling by that number of lines fails to bring point back into
    view, point is centered instead. The default value is zero, which
    (by default) causes point to always be centered after scrolling.
*** scroll-up-aggressively                                   :display:window:
    This variable directly specifies the vertical position of point
    after scrolling. The value of this variable should be either ~nil~
    (the default), or a floating point number /f/ between 0 and 1. The
    latter means that when point goes below the bottom window edge
    (i.e., scrolling forward), Emacs scrolls the window so that point
    is /f/ parts of the window height from the bottom window
    edge. Thus, larger /f/ means more aggressive scrolling: more new
    text is brought into view. The default value, ~nil~, is equivalent
    to 0.5.
*** scroll-down-aggressively                                 :display:window:
    This variable directly specifies the vertical position of point
    after scrolling. The value of this variable should be either ~nil~
    (the default), or a floating point number /f/ between 0 and 1. The
    latter means that when point goes above the top window edge (i.e.,
    scrolling backward), Emacs scrolls the window so that point is /f/
    parts of the window height from the top window edge. This, larger
    /f/ means more aggressive scrolling: more new text is brought into
    view. The default value, ~nil~, is equivalent to 0.5.
*** scroll-margin                                            :display:window:
    This variable restricts how close point can come to the top of
    bottom of a window (even if aggressive scrolling specifies a
    fraction /f/ that is larger than the window portion between the
    top and bottom margins). It's value is a number of screen lines;
    If point comes within that many lines of the top or bottom of the
    window, Emacs performs automatic scrolling. By default, this
    variable is 0. The effective margin size is limited to a quarter
    of the window height by default.
*** maximum-scroll-margin                                    :display:window:
    The effective margin size is limited to a quarter of the window
    height by default, but this limit can be increased up to half (or
    decreased down to zero) by customizing this variable.
*** auto-hscroll-mode                                        :display:window:
    By default, all the lines in the window are scrolled horizontally
    together, but if you set this variable to the special value of
    ~current-line~, only the line showing the cursor will be
    scrolled. To disable automatic horizontal scrolling entirely, set
    this variable to ~nil~. Note that when the automatic horizontal
    scrolling is turned off, if point moves off the edge of the
    screen, the cursor disappears to indicate that. (On text
    terminals, the cursor is left at the edge instead.)
*** hscroll-margin                                           :display:window:
    This variable controlls how close point can get to the window's
    left and right edges before automatic scrolling occurs. It is
    measured in columns. For example, if the value is 5, then moving
    point within 5 columns of an edge causes horizontal scrolling away
    from that edge.
*** hscroll-step                                             :display:window:
    This variable determines how many columns to scroll the window
    when point gets too close to the edge. Zero, the default value,
    means to center point horizontally within the window. A positive
    integer value specifies the number of columns to scroll by. A
    floating-point number (whose value should be between 0 and 1)
    specifies the fraction of the window's width to scroll by.
* Context
** anywhere
   literally anywhere
** editing
   when editing a buffer
** navigating
   When in a buffer that is possible to navigate with the standard
   ~C-f~, ~C-b~, ~C-n~, ~C-p~ commands
** minibuffer
   when in the minibuffer
** completion-buffer
   when in the window with current completion options
** password
   when typing in a password for minibuffer
   [[Entering passwords]]
** yes-no
   when echo prompt ends with ~(y or n)~
   [[Yes or No Prompts]]
** help
   Window that appears below buffer with some contents of a help
   buffer. One such help window is activated with [[help-for-help]]
** info
   The documentation browser. Able to read just every possible
   documentation imaginable.
** special-text
   When one location inside text might behave differently from the
   rest of the text. For example, links in *Help* buffers. Seems to
   mostly be for links or clickable locations in text.
** rectangle
   When Rectangle Mark mode is enabled and therefore an active region
   is highlighted as a rectangle.
** cua
   CUA mode which sets up key bindings that are compatible with the
   Common User Access (CUA) system used in many other applications.
** cua-rectangle
   The enhanced rectangle selection mode provided by cua. Check out
   CUA Rectangle Mark mode
** register
   When there is a prompt for a register in the minibuffer
** bookmark
   Bookmark Menu mode
* Faces
** The Minibuffer
*** minibuffer-prompt                                          :echo:display:
    When the minibuffer is in use, it appears in the echo area, with a
    cursor. The minibuffer starts with a /prompt/, usually ending with
    a colon. The prompt states what kind of input is expected, and how
    it will be used. The prompt is highlighting using this face.
** The Mark and the Region
*** region                                                   :region:display:
    Setting the mark at a position in the text /activates/ it. When
    the mark is active, we say that the region is active; Emacs
    indicates its extent by highlighting the text within it, using
    this face.
** Killing and Moving Text
*** secondary-selection                                      :region:display:
    When using ~mouse-set-secondary~ the selected text is highlighted,
    using this face as you drag.
* .emacs addition
** Registers
*** Saving Text in Registers
    If you always want to use a register separator in all buffers you
    can use the following setting.

    #+BEGIN_SRC emacs-lisp
    (setq register-separator ?+)
    (set-register register-separator "\n\n")
    #+END_SRC
    
*** Keeping File Names in Registers
    Generic lisp code for storing a file name in a particular
    register.

    #+BEGIN_SRC emacs-lisp
    (set-register <r> '(file . <name>))
    #+END_SRC

    Example code
    #+BEGIN_SRC emacs-lisp
    (set-register ?z '(file . "/gd/gnu/emacs/19.0/src/ChangeLog"))
    #+END_SRC
    puts the file name shown into register 'z'.
* Niche Modes
** Bookmark Menu
*** Description
    Use this buffer to edit bookmark definitions or annotate the
    bookmarks.
*** Enter Mode
    ~C-x r l~
*** Find Commands
    ~C-h m~
* Notes
** Undo
   There are a few ways someone can break a sweat in Emacs and wonder
   what has gone wrong. My experience has told me that Emacs does not
   immediately make it obvious how to undo each of these scenarios. It
   is important to understand each one.
*** My screen looks entirely different than what I had been working on
    In this case it is likely that the user "switched buffers". You
    can think of buffers as like different tabs in a browser. Emacs
    has different tabs too that can hold different content that you
    are working on. Likely you accidentally switched tabs (buffers)
    without realizing it. Switching back to what you were working on
    is simple. You can hit the keys ~C-x b <RET>~ and it should bring
    you back to the tab (buffer) you were working in. If you are
    nervous about keyboard shortcuts, likely you are using a version
    of Emacs that should have a menu at the top. One of the menu items
    should say /Buffers/. Click on this menu item and you can see all
    the open tabs. There are some tabs that are always available by
    default like the /GNU Emacs/ welcome screen, or a space that
    serves as essentially /scratch/ paper. Emacs requires that you
    name each file that you work on, so you should find the name of
    that file in this list of tabs (buffers). Try to think of this
    separation of work as buffers though as it makes memorizing the
    shortcut keys easier. In this case ~C-x~ is the command for what I
    think of as e-*x*-tra commands, and then when I hit the key ~b~
    I'm indicating I want to switch buffers. You can type the buffer
    name explicitly, but normally when you switch away from a buffer,
    just hitting enter will return you to the buffer you just left.
*** My cursor isn't returning to the spot I was working on
    Likely your cursor is at the bottom of the screen in what is
    called the /Echo Area/. Your cursor gets moved here when you are
    in the middle of an instruction to Emacs. If you did not intend to
    tell Emacs anything, there are two methods to escaping this
    area. One is ~C-g~. This is often a universal way to escape a
    command. It is very helpful. I have found every once in a while
    this method does not work in which case the command ~<ESC> <ESC>
    <ESC>~ normally does the trick for me. Please note that it is best
    practice after hitting ~<ESC> <ESC> <ESC>~ to then type
    ~C-g~. This avoids unintended effects due to quirks in Emacs
    commands.

    The ~<ESC>~ key can sometimes double as the ~<META>~ key if your
    computer is missing an ~<ALT>~ key or a keybinding in Emacs is
    overridden by your computer. Sometimes when you are nervous it's
    easy to just keep hitting ~<ESC>~ until the problem in Emacs is
    finished. If you hit ~<ESC>~ four (4) times, there's a possibility
    the next key you hit will be interpreted as being tied to a meta
    command. For example, ~<ESC> q~ will wrap text according to your
    preferences (or preset preferences). For this reason, if you hit
    ~C-g~ after hitting ~<ESC> <ESC> <ESC>~ you are less likely to
    have unintended consequences.
*** My Emacs screen appears to be split in half
    Each part of the screen is called a /window/. This can be
    confusing for new users since we are used to a window being
    whatever we can minimize in our operating system. The thing to
    keep in mind is that Emacs has been around for a long time, back
    when computers were only text. It used to be that what you see in
    the Emacs frame was the entire screen of old computers. This is
    why the word /window/ was used, and for consistency has not been
    changed. There are two commands I use most to make it so there is
    only one window, and it is the window I care about. The first is
    ~C-x o~. This moves my cursor from window to window. I use this
    until I see my cursor blinking in the window I care about. Once
    the cursor is in the window I care about, I use the command ~C-x
    1~. This is essentially saying "I want one (1) window, and I want
    it to be the active window."
*** I made a sudden huge edit I did not mean to make
    This is the normal way we think of undo! This command is fairly
    straight forward, but I have found the Emacs documentation doesn't
    make it easy to find. The command is ~C-/~.
*** My screen looks like a long list, I can't type, what's happening?
    Sometimes Emacs switches into a special mode without making it
    clear. If your screen looks like a long list do not type. So far
    there have been two keys in these scenarios that appear to be
    fairly universal regardless of the specific mode you have found
    yourself in. ~h~ will bring up a small help window, and ~q~ will
    quit the mode. Emacs and Emacs manuals do a terrible job
    telegraphing this information to the user.
** Language
   There are times when first reading an Emacs manual, you will run
   into language that you don't understand because Emacs hasn't
   defined it yet. In an attempt to make this easier on people here is
   some of the language Emacs forgets is new for lots of people
*** customize the variable
    Emacs has so much customizability. Basically anything in Emacs you
    can imagine is possible to customize. This means that Emacs makes
    a lot of assumptions for you when you start up Emacs. Each
    assumption is held in a value called a /Variable/. If you want to
    change one of the assumptions that Emacs has made for you, then
    you need to change the value of the associated variable. This is
    what Emacs means when they say "customize the variable". They are
    saying "You can change the set of assumptions we made".

    TODO: How do you actually make those changes.
** Emacs manual
   On my Ubuntu computer, when I installed Emacs, the official Emacs
   manual was not included for some strange reason. I needed to
   install the package ~emacs-common-non-dfsg~ for Emacs 26 and up
   onto my computer from the command line (it's a Linux package, not
   an Emacs package).
